# Admin(管理) #

## 云计算介绍 ##

服务器：机架式，塔式，机柜式，刀片式

典型服务模式：C/S ，Client/Server 架构 (由服务器提供资源或某种功能) (客户机使用资源或功能)

## TCP/IP协议 (支持跨网络架构，跨操作系统平台的通信) ##

主机之间通信要素：IP地址，子网掩码，IP路由

IP作用：用来标识一个节点的网络地址(点分十进制：一共32个二进制位 表示为4个十进制数，以.隔开)

IP地址分类：

A类 1~127 网+主+主+主 255.0.0.0

B类 128~191 网+网+主+主 255.255.0.0

C类 192~223 网+网+网+主 255.255.255.0

组播及科研 

D类 224~239 组播

E类 240~254 科研



## Linux系统介绍 ##

Unix 1969年底诞生

Linux 1991年10月 发布0.02版(第一个公开版) 内核 . 1994年3月 发布1.0版内核

Linux系统内核作用：管理CPU/内存，驱动基本硬件，文件系统

版本号：主版本.次版本.修订号

红帽 Linux http://www.redhat.com/  	

Fedora Core http://fedoraproject.org/

CentOS http://www.centos.org/



磁盘接口类型：IDE(hd表示IDE设备)与SCSI(sd表示SCSI设备)

命令行界面：[当前用户@主机名 工作目录]$ 

当前用户为root，则最后一个字符为# ,否则为$



## rpm包管理机制 ##

-软件名-版本信息.操作系统.硬件架构.rpm



查询已安装的RPM软件包的信息

rpm -q [子选项]  [软件名称]   支持通配符

 常用子选项

​	-a:列出已安装的所有软件包

​    -i:查看指定软件的详细信息

​    -l:查看指定软件的文件安装清单



查询某个目录/文件是哪个RPM包带来的

rpm -qf [文件路径]

即使目标文件被删除，也可以查询



查询未安装的rpm安装文件

rpm -q[子选项] [rpm包文件]

 常用子选项

​	 -pi:查看指定软件的详细信息

​	 -pl:查看指定软件的文件安装清单



安装

rpm -i rpm包文件

辅助选项

-v:显示细节信息

-h:以#号显示安装进程

--force:强制安装、覆盖安装

--test:测试安装、不做真实安装动作



卸载

rpm -e 软件名



导入红帽签名信息

rpm --import 前面文件所在位置



## YUM软件包管理 ##

基于RMP包构建的软件更新机制

自动解决软件包依赖关系

所有软件包由集中的YUM软件仓库提供



基本设置：/etc/yum.conf

仓库配置：/etc/yum.repos.d/*.repo

日志文件：/var/log/yum.log



.repo 基本配置项

-[源名称] ：自定义名称，具有唯一性

-name：本软件源的描述信息

-baseurl：指定yum服务的URL地址

-enabled：是否启动此配置

-gpgcheck：是否验证安装的RPM包

-gpgkey：用于RPM软件包验证的密钥文件



查看软件列表

yum list [软件名]



检索软件及相关信息

yum search 关键词

yum info [软件名]

yum provides 文档路径



安装/卸载软件包

yum [-y] 指令 [软件名]

常用指令

install:安装指定软件包

remove:卸载指定软件包



清空本地yum缓存

再次查询或更新时，会自动重建缓存 yum repolist

yum clean all 



## man手册 ##

man 命令

man 5 配置文件名

操作方法:

上下翻页 ，q键退出，按/键向后查找关键词(n、N切换)



## 制作链接文件 ##

ln 创建软链接

软连接 --> 原始文档 --> 文档数据

ln -s 原始文件或目录 软连接文件

若原始文件或目录删除，连接文件将失效，软连接可存放在不同分区/文件系统



ln 创建硬链接

硬链接 --> 文档数据

ln 原始文件 硬链接文件

若原始文件或目录删除，链接文件仍可用，硬链接与原始文件必须同一分区/文件系统



## zip归档工具 ##

归档+压缩操作

zip [-r] 备份文件.zip 被归档的文档

释放归档+解压操作

unzip 备份文件.zip [-d 目标文件夹]



## 用户账号管理 ##

用户(UID)、组(GID)

用户账号：超级用户root、系统用户、普通用户

组账号：基本组(私有组)、附加组(从属组)



/etc/passwd 用户信息

用户账号的名称：密码字符或占位符x：用户账号的UID号：所属基本组的GID号：用户全名：宿主目录：登录shell程序的路径



useradd 添加用户

useradd [选项]  用户名

常用命令选项：

-u:指定UID标记号

-d:指定宿主目录(家目录)，缺省为/home/用户名

-G:指定索书号的附加组

-s:指定用户的登录解释器



usermod 修改用户

usermod [选项] 用户名

常用命令选项：

-l:更改用户账号的登录名称

-u:用户id

-d:家目录路径

-s:登录解释器

-G:附加组      //重置附加组



/etc/shadow 用户密码/有效期等信息

用户账号的名称：加密后的密码字符串：上次修改密码的时间：密码的最短有效天数，默认0：密码的最长有效天数，默认99999：密码过期前的警告天数，默认7：密码过期后多少天禁用此用户账号：账号失效时间，默认为空：保留字段(未使用)



用户初始配置文件

新建用户时，根据/etc/skel模板目录复制

主要的初始配置文件

~/.bash_profile:每次登录时执行

~/.bashrc:每次进入新的Bash环境时执行

全局配置文件:/etc/bashrc、/etc/profile



userdel 删除用户

userdel [-r] 用户名

添加 -r 选项,宿主目录/用户邮件也一并删除



/etc/group 组信息

组账号的名称：密码占位符x：组账号的GID号：本组的成员用户列表



/etc/gshadow 组账号的管理信息

组账号的名称：加密后的密码字符串：本组的管理员列表：本组的成员用户列表



groupadd 添加组账号

groupadd [-g GID] 组名



gpasswd 管理组成员

gpasswd [选项]  组名

常用命令选项:

-A:定义组管理员列表

-a:添加组成员，每次只能加一个

-d:删除组成员，每次只能删一个

-M:定义组成员用户列表，可设置多个



groupdel 删除组

groupdel 组名

删除的目标组不能是用户的基本组



## 周期性计划任务 ##

cron 按照设置的时间间隔为用户反复执行某一项固定的系统任务

软件包:cronie、crontabs

系统服务:crond

日志文件:/var/log/cron



管理计划任务策略

编辑：crontab -e [-u 用户名]

查看：crontab -l [-u 用户名]

清除：crontab -r [-u 用户名]



配置可参考/etc/crontab文件

分:从0到59之间的整数 				时:从0到23之间的整数 日:从1到31之间的整数 月:从1到12之间的整数 周:0~7之间的整数，0或7代表星期日  任务命令行(绝对路径)

*:匹配范围内任意时间

,:分割多个不连续的时间点

-:指定连续时间范围

/n:指定时间频率，每n

0	 8	*	 *	 * 				#每天早晨八点整执行一次

0 	8    * 	* 	5 				#每周的周五，早晨八点整执行一次

0 	8    *     *     1-5 			#每周一到周五，早晨八点整执行一次

0     8    *     *     1，3，7    #每周一，周三，周日，早晨八点整执行一次

0     8    1     *      1				#每周的周一，早晨八点整执行一次 或 每月的一号，早晨八点整执行一次

*/5	*/5	*	*	*		     #每隔5分钟或每隔5小时，执行一次

0     */2  *    *    *   			   #每个两小时，都执行一次





# Engineer(工程师) #

## 权限和归属 ##

ls -l 命令查看

权限位：硬链接数：属主：属组：大小：最后修改时间：文件/目录名称



chmod 命令

chmod [ugo] [+-=] [rwx] 文件

chmod [数字] 文件

常用命令选项

-R:递归修改权限



权限位的八进制数表示

r、w、x分别对应4、2、1，后3组分别求和



文件/目录的默认权限

取决于umask设置（最高权限减umask值）

默认0022

查看对应关系 umask -S 

umask 数字 修改umask



创建新的文件夹的时候，可以直接设置权限

mkdir -m 



设置归属关系

chown命令

chown 属主 文件

chown 属主:属组 文件

chown :属组 文件

常用命令选项:

-R:递归修改权限



### 附加权限！！！ ###

Set UID 字符表示为s 数字表示4 User的x位 （当其他用户执行带SUID标记的程序时，具有此程序属主的身份和相应权限）

Set GID 字符表示为s 数字表示2 Group的x位 （在一个具有SGID权限的目录下，新建的文档会自动继承此目录的属组身份）

Sticky Bit 字符表示为t 数字表示1 Other的x位 （设用于目录，用于限制用户滥用写入权限，在设置了粘滞位的文件夹下，即使用户有写入权限，也不能删除或改名其他用户文档）



ACL策略

可以针对个别用户，个别组设置独立的权限

大多数挂载的EXT3/4、XFS文件系统默认已支持



定义ACL策略

setfacl命令

​			setfacl [选项] u:用户名:权限 文件

​			setfacl [选项] g:组名:权限 文件

常用命令选项:

​			-m:定义一条ACL策略

​			-x:清除指定的ACL策略

​			-b:清除所有已设置的ACL策略

​			-R:递归设置ACL策略



## 磁盘分区 ##

识别硬盘lsblk-> 分区规划fdisk-> 格式化mkfs.-> 挂载使用



### MBR/msdos分区模式 ###

1~4个主分区、或者0~3个主分区+1个扩展分区（n个逻辑分区）

最大支持容量为2.2TB的磁盘

扩展分区不能格式化



使用fdisk分区工具

查看分区表

fdisk -l /dev/sda

修改硬盘的分区表

fdisk 硬盘设备

常用交互指令:

​						m 列出指令帮助

​						p 查看现有的分区表

​						n 新建分区

​						d 删除分区

​						q 放弃更改并退出

​						w 保存更改并退出



识别新分区表 (当硬盘的分区表被更改以后，需要将分区表的变化及时通知Linux内核，最好reboot一次，否则再访问分区时可能会找不到准确的设备)

partprobe 硬盘设备 



格式化

windows常见的文件系统 NTFS FAT

Linux常见的文件系统 ext4(RHEL6) XFS (RHEL7)



mkfs 工具

mkfs.ext3 	分区设备路径

mkfs.ext4     分区设备路径

mkfs.xfs	   分区设备路径

mkfs.vfat	 分区设备路径



访问文件系统

mount 硬盘设备 挂载点

df 检查使用情况 df -hT 挂载点



修改/etc/fstab实现开机自动挂载

设备路径  挂载点 类型 参数 备份标记  检测顺序



### GPT分区模式 ###

最多支持128个主分区，最大支持18EB磁盘

1EB = 1024 PB = 1024 x 1024 TB



parted工具

常见分区指令：

​					help											查看指令帮助

​					mktable msdos|gpt 				建立指定模式分区表								

​					mkpart primary 文件系统 start end 		指定大小或百分比%作为起始、结束位置

​					print 										   查看分区表

​					rm 序号									   删除指定的分区

​					quit											  退出交互环境





### 交换空间 ###

#### 利用分区扩展Swap空间 ####

格式化分区 

mkswap 分区设备



启用交换分区

swapon 分区设备 



查看交换分区

swapon -s 



停止交换分区

swapoff 分区设备

扩展交换空间执行上述操作即可



#### 利用文件扩展Swap空间 ####

文件扩展交换空间：建立一个大文件，将这个大文件所占用的硬盘空间，进行制作交换空间

dd if=源设备 of=目标设备 bs=块大小 count=快数 #利用dd命令将文件快速变大

dd if=/dev/zero of=/opt/swap.db bs=1M #/dev/zero:可以源源不断产生数据



格式化交换文件

mkswap -f 交换文件

选项 -f 表示强制执行



启用交换分区

swapon /交换文件



查看交换分区

swapon -s 



停止交换分区

swapoff /交换文件

扩展交换空间执行上述操作即可



### 逻辑卷 ###

LVM工作方式

在“分区”-->“格式化” 中间增加一个逻辑层

零散空间存储(物理卷pv) ---- 整合的虚拟磁盘(卷组vg) ---- 虚拟的分区(逻辑卷lv)



LVM管理工具

| 功能        | 物理卷管理 | 卷组管理  | 逻辑卷管理 |
| ----------- | ---------- | --------- | ---------- |
| Scan扫描    | pvscan     | vgscan    | lvscan     |
| Create创建  | pvcreate   | vgcreate  | lvcreate   |
| Display显示 | pvdisplay  | vgdisplay | lvdisplay  |
| Remove删除  | pvremove   | vgremove  | lvremove   |
| Extend扩展  | /          | vgextend  | lvextend   |



基本思路：

至少一个空闲分区 -> 创建卷组 vgcreate 卷组名 空闲分区 -> 创建逻辑卷 lvcreate -L 大小 -n 名称 卷组名



扩展逻辑卷

基本思路：

空闲分区 -> 检查卷组空间是否够用，不够则扩展卷组 vgextend 卷组名 空闲分区 -> 扩展逻辑卷 lvextend -L 新大小 /dev/卷组名/逻辑卷名



更新文件系统大小(适用于格式化过的逻辑卷，扩容后应该更新文件系统大小)

resize2fs EXT3/4设备 或者 xfs_growfs XFS设备



LVM卷组的PE大小

创建卷组时设置PE大小

vgcreate -s PE大小 卷组名 空闲分区



创建逻辑卷时指定PE个数

lvcreate -l PE个数 -n 逻辑卷名 卷组名



### VDO(虚拟数据优化器) ###

一个内核模块，目的是通过重删减少磁盘的空间占用，以及减少复制带宽

VDO是基于块设备层之上的，也就是在原设备基础上映射出mapper虚拟设备，然后直接使用即可

需要 vdo 、kmod-kvdo 软件包



重复数据删除

输入的数据会判断是不是冗余数据

判断为重复数据的部分不会被写入，然后对源数据进行更新，直接指向原始已经存储的数据块即可。

压缩

对每个单独的数据块进行处理



至少需要2G内存

基础命令

可以参考man vdo

vdo create --name=vdo卷名称 --device=设备路径 --vdoLogicalSize=逻辑大小

vdo list 

vdo status -n vdo卷名称

vdo remove -n vdo卷名称

vdostatus [--human-readable] [/dev/mapper/vdo卷名称]  #查看设备详细信息



vdo卷的格式化加速(跳过去重分析,格式化时会很快)

mkfs.xfs -K /dev/mapper/vdo卷名称						

mkfs.ext4 -E nodiscard /dev/mapper/vdo卷名称



vdo开机自动挂载

/dev/mapper/vdo[数字] /挂载点 xfs defaults,_netdev 0 0 



### RAID磁盘阵列 ###

廉价冗余磁盘阵列

通过硬件/软件技术，将多个较小/低速的磁盘整合成一个大磁盘

价值：提升I/O效率，硬件级别的数据冗余

不同RAID级别的功能、性能各不相同



实现方式

硬RAID:由RAID控制卡管理陈列

主板-> 陈列卡-> 磁盘-> 操作系统->数据

软RAID:由操作系统来管理阵列

主板-> 磁盘 -> 操作系统 -> RAID软件->数据

RAID0/1/10

RAID0 条带模式

同一个文档分散存放在不同磁盘

并行写入以提高效率



RAID1镜像模式

一个文档复制成多份，分别写入不同磁盘

多份拷贝提高可靠性，效率无提升



RAID0+1 / RAID1+0

整合RAID0 、RAID的优势

并行存取提高效率、镜像写入提高可靠性





RAID5 高性价比模式

相当于RAID0和RAID1的这种方案

需要至少一块磁盘的容量来存放校验数据



RAID6 高性价比/可靠模式

相当于RAID5阵列，提供2份独立校验方案

需要至少两块磁盘的容量来存放校验数据



| 对比项     | RAID0 | RAID1 | RAID10 | RAID5 | RAID6 |
| ---------- | ----- | ----- | ------ | ----- | ----- |
| 磁盘数     | 2     | 2     | 4      | 3     | 4     |
| 存储利用率 | 100%  | <=50% | <=50%  | n-1/n | n-2/n |
| 校验盘     | 无    | 无    | 无     | 1     | 2     |
| 容错性     | 无    | 有    | 有     | 有    | 有    |
| IO性能     | 高    | 低    | 中     | 较高  | 较高  |



### 进程管理 ###

查看进程树 

pstree  [选项] [PID或用户名]

常用命令选项:

-a：显示完整的命令行

-p：列出对应PID号



查看进程快照

ps [选项]

常用命令选项:

aux：显示当前终端所有进程(a)、以用户格式输出(u)、当前用户在所有终端下的进程(x)

-elf：显示系统内所有进程(-e)、以长格式输出(-l)、信息、包括最完整的进程信息(-f)



ps aux 列出正在运行的所有进程

用户		进程ID		%CPU		%内存		虚拟内存		固定内存		终端		状态		起始时间		CPU时间		程序指令



ps -elf 列出正在运行的所有进程

PPID：父进程的PID号

PRI/NI：进程优先级，数值越小优先级越高



进程动态排名

top 交互式工具

top [-d 刷新秒数] [-u 用户名]



检索进程

pgrep [选项] 查询条件

常用命令选项:

-l：输出进程名，而不仅仅是PID

-U：检索指定用户的进程

-x：精确匹配完整的进程名



控制进程

在命令行末尾添加"&"符号，不占用当前终端，后台启动



jobs命令 

查看后台任务列表

jobs -l 



fg命令(默认序号则为最近一个任务)

将后台任务恢复到前台运行



bg命令(默认序号则为最近一个任务)

激活后台被挂起的命令

bg 序号 激活



杀死进程(-9表示强制)

kill [-9] Pid 、kill [-9] %后台任务编号

killall [-9] 进程名

pkill [-9] 查找条件 （pkill -9 -U 用户名:强制踢出用户）



## 网络参数配置 ##

配置静态主机名

/etc/hostname  固定保存的主机名，对本机有效



查看网络连接

使用show命令

nmcli connection show 

nmcli connection show "连接名"



修改网络连接配置

使用modify指令

nmcli connection modify "连接名" 参数1 

常用参数：

ipv4.method auto|manual 

ipv4.addresses 'ip地址/掩码长度'

ipv4.gateway 网关地址

connection.autoconnect yes|no



激活/禁止网络连接

使用up/down指令

nmcli connection down “连接名”

nmcli connection up ”连接名“



为本机指定DNS服务器

配置文件/etc/resolv.conf

关键记录：nameserver DNS服务器地址



查看IP地址

ip address show 

添加ip地址

ip address add ip地址/掩码位数 dev ens33 



ping命令，测网络连接

-选项 -c 包个数



使用scp远程复制工具

scp [-r] 用户名@服务器:路径 本地路径

scp [-r] 本地路径 用户名@服务器:路径



实现ssh无密码验证

部署公钥与私钥

生成公钥与私钥 ssh-keygen (一路回车)

传递公钥到对方主机 ssh-copy-id 对面ip 

查看(ls /root/.ssh/authorized_keys)



### 源码编译安装 ###

基本实现过程：

下载源码包-> tar解包，释放源代码至指定目录 (下载gcc make gcc-c++)

./configure 配置，指定安装目录/功能模块等选项 (选项：--prefix=安装目录)

make 编译，生成可执行的二进制程序文件

make install 安装，将编译好的文件复制到安装目录



### 自定义yum仓库 ###

yum仓库特点

大量的.rpm软件安装包文件

针对这些软件包的repodata/仓库档案

repodata/仓库档案数据

filelists.xml.gz		软件包的文件安装清单

primary.xml.gz		软件包的基本/主要信息

other.xml.gz			软件包的其他信息

repomd.xml			提供.xml.gz下载和校验信息



创建repodata/档案

createrepo /生成仓库数据文件



配置客户端文件

.repo

[]

name=

baseurl=file:///

enabled=

gpgcheck=



### 日志管理 ###

内核及系统日志

由系统服务rsyslog统一记录/管理

日志消息采用文本格式

主要记录事件发生的时间、主机、进程、内容



内核及系统日志

常见的日志文件

| 日志文件         | 主要用途                         |
| ---------------- | -------------------------------- |
| /var/log/message | 记录内核消息、各种服务的公共消息 |
| /var/log/dmesg   | 记录系统启动过程的各种消息       |
| /var/log/cron    | 记录与cron计划任务相关的消息     |
| /var/log/maillog | 记录邮件收发相关的消息           |
| /var/log/secure  | 记录与访问限制相关的安全消息     |



用户日志

由登录程序负责记录/管理

日志消息采用二进制格式

记录登录用户的时间、来源、执行的命令等消息

| 日志文件         | 主要用途                         |
| ---------------- | -------------------------------- |
| /var/log/lastlog | 记录最近的用户登录事件           |
| /var/log/wtmp    | 记录成功的用户登录/注销事件      |
| /var/log/btmp    | 记录失败的用户登录事件           |
| /var/run/utmp    | 记录当前登录的每个用户的相关信息 |



用户登录分析

users、who、w命令

查看已登录的用户信息，详细度不同

last、lastb命令(可以配合-数字 查看几条)

查看最近登录成功/失败的用户信息



日志消息的优先级

Linux内核定义的事件紧急程度

分为0~7 共8种优先级别

其数值越小，表示对应事件越紧急/重要

```sell
   #define KERN_EMERG    "<0>"  /* system is unusable               */
   #define KERN_ALERT    "<1>"  /* action must be taken immediately */
   #define KERN_CRIT     "<2>"  /* critical conditions              */
   #define KERN_ERR      "<3>"  /* error conditions                 */
   #define KERN_WARNING  "<4>"  /* warning conditions               */
   #define KERN_NOTICE   "<5>"  /* normal but significant condition */
   #define KERN_INFO     "<6>"  /* informational                    */
   #define KERN_DEBUG    "<7>"  /* debug-level messages             */
```
0 紧急 会导致主机系统不可用的情况

1 警告 必须马上采取措施解决的问题

2 严重 比较严重的情况

3 错误 运行出现错误

4 提醒 可能会影响系统功能的事件

5 注意 不会影响系统但值得注意

6 信息 一般信息

7 调试 程序或系统调试信息等



使用journalctl 工具

提取由systemd-journal 服务搜集的日志

-主要包括内核/系统日志、服务日志

常见用法：

journalctl | grep 关键词

journalctl -u 服务名 [-p 优先级]

journalctl -n 消息条数



### SELinux安全机制 ###

由美国NSA国家安全局主导开发，一套增强Linux系统安全的强制访问控制体系

集成到Linux内核(2.6及以上)中运行

RHEL7基于SELinux体系针对用户、进程、目录、和文件提供了预设的保护策略，以及管理工具



SELinux的运行模式

enforcing(强制)	permissive(宽松)	disabled(彻底禁用)

切换运行模式

​	临时切换：setenforce 1|0

​	固定配置：/etc/selinux/config



### 重设root用户密码 ###

重启系统，进入recovery恢复模式

按e键，找到linux16行，末尾添加 rd.break console=tty0

按ctrl + x 启动



以可写方式重新挂载/sysroot，并切换到此环境

switch_root#mount -o remount,rw /sysroot

switch_root#chroot /sysroot



将root用户的密码设置为abc

echo abc | passwd --stdin root



重设SELinux安全标签

touch ./autorelabel



先后执行exit、reboot完成修复



### firewalld服务 ###

Linux防火墙体系

系统服务：firewalld

管理工具：firewall-cmd 、firewall-config



预设安全区

public：仅允许访问本机的sshd等少数几个服务

trusted：允许任何访问

block：阻塞任何来访请求

drop：丢弃任何来访的数据包



配置规则的位置

运行时(runtime)

永久(permanent)



查看防火墙规则列表

firewall-cmd --list-all [--zone=区域名]

firewall-cmd --list-all-zones (查看所有区域)

firewall-cmd --get-zones (查看已设置区域)

firewall-cmd --get-services (查看服务)

firewall-cmd --get-default-zone (查看默认区域)



配置防火墙

指定默认的安全区域

使用--set-default-zone=区域名

默认为public，限制较严格



封网段，开服务

若针对”永久配置“，需添加 --premanent

使用 --add-source=网段地址

使用 --add-service=服务名

firewall-cmd --reload 重载配置



### 服务管理 ###

init程序的作用

Linux系统和服务管理器

是内核引导之后加载的第一个初始化进程(PID=1)

负责掌控整个Linux的运行/服务资源组合

传统的init程序风格

system v：顺序加载，RHEL5系列采用

upstart：事件触发，RHEL6系列采用



systemd

一个更高效的系统&服务管理器

开机服务并行启动，各系统服务间的精确依赖

配置目录：/etc/systemd/system/

服务目录：/lib/systemd/system/

主要管理工具：systemctl 



列出服务

列出活动的系统服务

systemctl -t service 

列出所有系统服务(包括不活动的)

systemctl -t service all



管理运行级别

切换级别

列出可用运行级别

systemctl -t target 

切换到文本/图形模式

systemctl isolate multi-user.target

systemctl isolate graphical.target

runlevel 查看运行级别



设置默认级别

systemctl get-default 查看默认级别

systemctl set-default multi-user.target 设置默认级别为文本

systemctl set-default graphical.target 设置默认级别为图形



# Network(网络) #

实现资源共享，信息传递，增加可靠性，提高系统处理能力



计算机发展阶段

60年代 分组交换 70-80年代 TCP/IP 90年代后 Web技术



网络标准

标准化组织：ISO(国际标准化组织) IEEE(电气和电子工程师协会)



WAN与LAN

广域网：连接远距离计算机网络(internet)

局域网：连接较短距离内计算机(企业网、校园网)



网络拓扑结构

线缆连接计算机和网络设备的布局

点对点：两台设备之间有一条单独的连接，专用的广域网中电路连接的两台路由器

星型及扩展的星型：易于实现、易于网络扩展、易于故障排查，但中心节点压力大、组网成本较高

网状：一个节点与其他多个节点相连，提供冗余性和容错性、可靠性高、组网成本高



OSI参考模型

将复杂的流程分解，复杂问题简单化，更容易发现问题并针对性的解决问题

国际标准化组织1984年颁布

物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

TCP/IP五层模型(与设备对应关系)：物理层(网卡)、数据链路层(交换机)、网络层(路由器)、传输层(防火墙)、应用层(计算机)



协议数据单元 (PDU)

物理层 -> 比特流

数据链路层 -> MAC头部|IP头部|TCP头部|上层数据 -> 数据帧

网络层 -> IP头部|TCP头部|上层数据 -> 数据包

传输层 -> TCP头部|上层数据 -> 数据段

应用层 -> 上层数据 -> 数据段



## eNSP软件 ##

图形化网络仿真平台 



华为交换机的命令行

-用户视图

<Huawei>



-系统视图

<Huawei>system-view

[Huawei]



-接口视图

[Huawei]interface Ethernet 0/0/1

[Huawei-Ethernet0/0/1]

-interface：接口

-Ethernet：接口类型

-0/0/1：接口号



-协议视图

[Huawei]ospf

[Huawei-ospf-1]



命令行层级关系

用户视图 -> 查看运行状态或其他参数

系统视图 -> 配置设备的系统参数等

接口视图 -> 配置接口参数

协议视图 -> 配置路由协议



视图间的切换 

quit 退出本层

return 返回到用户视图

快捷键 Ctrl +z 回到用户视图



忽略一些提示信息

undo terminal debugging

undo terminal logging

undo terminal monitor

undo terminal trapping

sys

user-interface console 0

idle-timeout 0 0



### 交换机基本配置 ###

配置主机名

<Huawei>system-view 

[Huawei]sysname lianxi1

[lianxi1]



显示VRP版本

<Huawei>display version 



查看交换机配置

<Huawei>display current-configuration 



使用账户和密码登录终端

<Huawei>system-view 

[Huawei]aaa

[Huawei-aaa]local-user admin01 password cipher admin01 

[Huawei-aaa]quit

[Huawei]user-interface console 0

[Huawei-ui-console0]authentication-mode aaa

(退出后重新进入需要身份验证)



保存交换机的配置

<Huawei>save

The current configuration will be written to the device.
Are you sure to continue?[Y/N]y



恢复设备出厂默认值

<Huawei>reset saved-configuration

The configuration will be erased to reconfigure. Continue? [Y/N]:y



避免自动退出配置界面

空闲一段时间后(默认控制台会话时间为10分钟)，重回初始界面

解决方法：

<Huawei>system-view 

[Huawei]user-interface console 0

[Huawei-ui-console0]idle-timeout 100



查看MAC地址表

<Huawei>display mac-address





## 数据链路层解析 ##

以太网MAC地址

用来识别一个以太网上的某个单独的设备或一组设备



以太网帧格式

目的地址|源地址|类型/长度|数据|帧校验序列

6字节|6字节|2字节|46~1500字节|4字节



### 交换机 ###

用来连接局域网的主要设备

能够根据以太网帧中目标地址智能的转发数据，因此交换机工作在数据链路层



工作原理

学习：MAC地址表是交换机通过学习接受的数据帧的源MAC地址来形成的

广播：如果目标地址在MAC地址表中没有，交换机就向除接收到该数据帧的接口外的其他所有接口广播该数据帧

转发：交换机根据MAC地址表单播转发数据帧

更新：交换机MAC地址表的老化时间是300秒，交换机如果发现一个帧的入接口和MAC地址表中源MAC地址的所在接口不同，交换机将MAC地址重新学习到新的接口



### VLAN ###

广播域：指接收同样广播消息的节点的集合，交换机的所有接口默认属于同一个广播域

VLAN：虚拟局域网，是物理设备上连接的不受物理位置限制的用户的一个逻辑组

(随着接入设备的增多，网络中的广播增多，降低了网络的效率，分割广播域，引入vlan)

作用：广播控制，增加安全性，提高网络带宽，降低延迟



#### vlan配置 ####

创建/删除vlan

[Huawei]vlan 数字 

[Huawei]vlan batch 多个数字 (批量创建vlan)

[Huawei]vlan batch 数字 to 数字 (批量创建vlan)

[Huawei]undo vlan 数字 删除

[Huawei]undo vlan batch 多个数字 (批量删除vlan)



将接口加入vlan 

在接口视图中首先修改成Access，再加入

[Huawei]interface Ethernet0/0/1

[Huawei-Ethernet0/0/1]port link-type access 

[Huawei-Ethernet0/0/1]port default vlan 2



批量将接口加入vlan

首先将某些接口加入接口组，然后将接口组加入vlan

[Huawei]port-group 1

[Huawei-port-group-1]group-member Ethernet 0/0/1 Ethernet 0/0/2

[Huawei-port-group-1]group-member Ethernet 0/0/1 to Ethernet 0/0/10

[Huawei-port-group-1]port link-type access 

[Huawei-port-group-1]port default vlan 2



验证vlan的配置

[Huawei]display vlan 2



Trunk原理

交换机通过Trunk链路，每个去往其他交换机的数据帧上会有标记

接入链路 access 可以承载1个vlan的数据

中继链路 trunk 可以承载多个vlan的数据 



Trunk配置

进入端口后修改端口链路类型，修改trunk模式的端口添加允许的vlan

[Huawei]interface Eth0/0/1

[Huawei-Ethernet0/0/1]port link-type trunk

[Huawei-Ethernet0/0/1]port trunk allow-pass vlan all



链路聚合

Eth-trunk 

多条线路负载均衡，带宽提高

容错，当一条线路失效时，不会造成全网中断



配置链路聚合

创建链路聚合接口，进入接口，加入链路聚合

[Huawei]interface Eth-Trunk 1

[Huawei-Eth-Trunk1]trunkport Ethernet 0/0/1 0/0/2



恢复默认配置

[Huawei]clear configuration interface Ethernet 0/0/1

Warning: All configurations of the interface will be cleared, and its state will
 be shutdown. Continue? [Y/N] :y



## 网络层 ##

定义了基于IP协议的逻辑地址

连接不同的媒介类型

选择数据通过网络的最佳路径



ICMP协议

通过IP数据报传送，用来发送错误和控制信息

定义了许多信息类型：目的地不可达、TTL超时、信息请求、信息应答、地址请求、地址应答

ICMP检测双向通路的连通性

ping命令使用ICMP协议 ping [-t] [-l 字节数] 目标IP或主机名

常见的ping反馈结果：

连接建立成功，Replay from 目标地址..

目标主机不可达，Destination host unreachable .

请求时间超时，Request timed out.



路由原理及配置

将数据包从一个网络发送到另一个网络

需要依靠路由器来完成

路由器只关心网络的状态，决定最佳路径

路由器可以根据路由表选择最佳路径

每个路由器都维护着一张路由表，这是路由器转发数据包的关键

每条路由表记录指明了：到达某个子网或主机应从路由器的哪个物理接口发送，通过此接口可到达该路径的下一个路由器的地址(或直接相连网络中的目标主机地址)



静态路由

由管理员手工配置，为单向条目

通信双方的边缘路由器都需要指定，否则会导致数据包有去无回



配置静态路由

[Huawei]ip route-static 目标网络ID(*.0) 子网掩码 下一跳





默认路由

特殊的静态路由

目标网络为0.0.0.0 0.0.0.0 可匹配任何目标地址

只有当从路由表中找不到任何明确匹配的路由条目时，才会使用默认路由，一般在企业网关出口使用



三层交换机

二层交换+三层转发



在三层交换机上配置的vlan接口为虚接口

使用vlanif(vlan接口)实现vlan间路由

[Huawei]interface Vlanif VLAN interface number 

[Huawei]display ip interface brief (查看ip信息)



配置思路

确定哪些vlan需要配置网关

如果三层交换机上没有该vlan则创建它

为每个vlan创建相关的虚拟接口

给每个vlan虚拟接口配置ip

如果需要，配置三层交换机的动态或静态路由



动态路由

基于某种路由协议实现

减少了管理任务、占用了网络带宽



动态路由协议OSPF

开放式最短路径优先，适合大中型网络使用

OSPF区域

为了适应大型的网络，OSPF在网络内部划分多个区域

每个OSPF路由器只维护所在区域的完整链路状态信息

区域ID

区域ID可以表示成一个十进制的数字

也可以表示成一个IP

骨干区域Area0

负责区域间路由信息传播



OSPF基本配置

启动OSPF路由进程并进入首个区域

[Huawei]ospf 1
[Huawei-ospf-1]area 0
[Huawei-ospf-1-area-0.0.0.0]network 所在网段(192.168.1.0) 子网掩码(0.0.0.255)



## 传输层 ##

网络层提供点到点的连接(主机)

传输层提供端到端的连接(应用)



TCP传输控制协议

可靠的、面向连接的协议

传输效率低

UDP用户数据报协议

不可靠的、无连接的服务

传输效率高



TCP的连接与断开

TCP的连接---三次握手 

主机A 发送SYN，请求连接

主机B 发送SYN、ACK

主机A 发送ACK



TCP的四次断开

主机A 发送FIN，请求断开连接

主机B 发送ACK

主机B 发送FIN，请求断开连接

主机A 发送ACK



TCP应用：21 、22、25、53、80、443端口



UDP协议应用：69，53，123



### ACL访问控制列表 ###

ACL：应用在路由器接口的指令列表(即规则)

读取第三次、第四层报头文信息

格局预先定义好的规则对报文进行过滤



主要类型

| 分类    | 编号范围  | 参数                             |
| ------- | --------- | -------------------------------- |
| 基本ACL | 2000-2999 | 源IP地址                         |
| 高级ACL | 3000-3999 | 源IP地址、目的IP地址、端口、协议 |



ACL规则

每个ACL可以包含多个规则，路由器根据规则对数据流量进行过滤，匹配即停止



配置基本ACL

需求：禁止192.168.1.1访问服务器，允许其他所有的访问流量

[Huawei]acl 2000

[Huawei-acl-basic-2000]rule 5 deny source 192.168.1.1 0

[Huawei-acl-basic-2000]quit

[Huawei-GigabitEthernet0/0/0]traffic-filter outbound acl 2000



配置高级ACL

需求：允许192.168.1.1访问192.168.3.1的web服务，允许192.168.1.1访问网络192.168.2.0/24，禁止访问其他网络

[Huawei]acl 3000

[Huawei-acl-adv-3000]rule 5 permit tcp source 192.168.1.1 0 destination 192.168.
3.1 0 destination-port eq 80

[Huawei-acl-adv-3000]rule 10 permit ip source 192.168.1.1 0 destination 192.168.
2.0 0.0.0.255

[Huawei-acl-adv-3000]rule 15 deny ip source any

[Huawei-acl-adv-3000]quit 

[Huawei]int g0/0/2

[Huawei-GigabitEthernet0/0/2]traffic-filter inbound acl 3000

其他命令

如果不需要限制时，可以取消入方向的acl，如果是出方向就把inbound 改成outbound

[Huawei-GigabitEthernet0/0/1]undo  traffic-filter  inbound 		

如果配置规则有误，可以根据查询到的规则号来删除

[Huawei-acl-basic-2000]dis this 

[Huawei-acl-basic-2000]undo  rule 5   



## NAT ##

网络地址转换

通过将内部网络的私有IP地址翻译成全球唯一的公网IP地址，使内部网络可以连接到互联网等外部网络上



私有IP地址分类

A类 10.0.0.0 ~ 10.255.255.255

B类 172.16.0.0 ~ 172.31.255.255

C类 192.168.0.0 ~ 192.168.255.255



优缺点

优点：节省公有合法IP地址、处理地址重叠、安全性

缺点：延迟增大、配置和维护的复杂性



实现方式：静态转换，Easy IP

### 静态转换 ###

静态转换是指将内部网络的私有地址转换为公有地址时，IP地址的对应关系是确定的

静态转换是一对一的转换，是双向的



配置静态转换

需求：将10.1.1.11/24、10.1.1.12/24静态转换为公网地址200.1.1.11/28、200.1.1.12/28，以便访问外网主机或被外网主机访问

[Huawei]int g0/0/2
[Huawei-GigabitEthernet0/0/2]nat static global 200.1.1.11 inside 10.1.1.11
[Huawei-GigabitEthernet0/0/2]nat static global 200.1.1.12 inside 10.1.1.12



### Easy IP ###

Easy IP允许将多个内部地址映射到网关出接口



配置Easy IP

需求：公司路由器外部接口G0/0/2是公网IP，如何使内部网络10.1.1.0/24利用NAT上网?

[Huawei]acl 2001

[Huawei-acl-basic-2001]rule 5 permit source 10.1.1.0 0.0.0.255 

[Huawei-acl-basic-2001]int g0/0/2

[Huawei-GigabitEthernet0/0/2]nat outbound 2001



## VRRP ##

虚拟路由冗余协议

VRRP能够在不改变组网的情况下，将多台路由器虚拟成一个虚拟路由器，通过配置虚拟路由器的IP地址为默认网关，实现网关的备份

VRRP组成员角色

主(master)路由器

备份(backup)路由器

虚拟(virtual)路由器



# SHELL(编程语言) #

在Linux内核与用户之间的解释器程序

通常指/bin/bash

负责向内核翻译及传达用户/程序指令

相当于操作系统的"外壳"



shell环境(cat /etc/shells)

可通过usermod、chsh更改登录shell或手动执行目标shell程序

/bin/sh								多数Unix默认的shell
/bin/bash							多数Linux默认使用的shell
/sbin/nologin					 非登录shell
/usr/bin/sh
/usr/bin/bash
/usr/sbin/nologin
/bin/tcsh
/bin/csh



Bash基本特性

快捷键、Tab键补齐

命令历史

命令别名

标准输入输出

重定向

管道操作



脚本创建步骤：新建文本文件、添加可执行的脚本语句(命令行)、添加x执行权限



## 脚本构成及执行 ##

规范的脚本构成：

```shell
#！ 脚本声明(使用哪种解释器)
#   注释信息(步骤、思路、用途、变量含义等)
可执行的语句
```



执行方式：

1、指定脚本文件的路径，前提是有x权限

2、作为“参数”

-sh：脚本文件路径

source 脚本文件路径

. 脚本文件路径



调试shell脚本

主要途径：

直接观察执行中的输出、报错信息

通过sh -x 开启调试模式

在可能出错的地方设置echo



简单的脚本应用

1.配置yum仓库

软件源位于/misc/cd

```shell
#!/bin/bash
rm -rf /etc/yum/repos.d/*.repo
echo '[cangku]'
name=RHEL7
baseurl=file:///misc/cd
gpgcheck=0
```

2.快速搭建ftp服务

```shell
#!/bin/bash
yum -y install vsftpd &> /dev/null
systemctl start vsftpd
systemctl enable vsftpd
```



## Shell变量 ##

以固定名字存放，可能会变化的值

提高脚本对任务需求，运行环境变化的适应能力

方便在脚本中重复使用



定义/赋值/查看变量

-变量名=变量值

相关注意事项：

1.若指定的变量名已存在，相当于为此变量重新赋值

2.等号两边不要有空格

3.变量名由字母/数字/下划线组成，区分大小写

4.变量名不能以数字开头，不要使用关键字和特殊字符



查看变量

-引用变量值：$变量名

-查看变量值：echo $变量名、echo ${变量名}



取消变量

变量的失效

退出定义变量的shell环境时，变量会自动失效

也可手动取消：unset 变量名



变量的种类

shell变量的分类角度

存储类型

整数型、浮点型、双精度浮点型、字符型、.....

shell脚本语言对存储类型要求较松散

| 类型       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| 环境变量   | 变量名通常都大写，由系统维护，用来设置工作环境，只有个别变量用户可以直接更改 |
| 位置变量   | bash内置，存储执行脚本时提供的参数                           |
| 预定义变量 | bash内置，一类有特殊用途的变量 ，可直接调用但不能直接赋值或修改 |
| 自定义变量 | 由用户自主设置、修改及使用                                   |



环境变量

配置文件：/etc/profile、~/.bash_profile

相关操作：

-env：列出所有的环境变量

-set：列出所有变量



预定义变量

用来保存脚本程序的执行信息

直接使用这些变量

不能直接为这些变量赋值

| 变量名 | 含义                                               |
| ------ | -------------------------------------------------- |
| $0     | 当前所在的进程或脚本名                             |
| $$     | 当前运行进程的PID号                                |
| $?     | 命令执行后的返回状态，0表示正常，1或其他值表示异常 |
| $#     | 已加载的位置变量的个数                             |
| $*     | 所有位置变量的值                                   |



位置变量

在执行脚本时提供的命令行参数

-表示为$n，n为序号

-$1、$2...${10}、${11}、...

```shell
#！/bin/bash
useradd $1 2> /tmp/err.log
echo 1234567 | passwd --stdin $1 &> /dev/null
```



变量值及范围控制

扩展赋值操作

区分三种定界符

双引号“” ：允许扩展，以$引用其他变量

单引号''：禁用扩展，即便$也视为普通字符 与$()等效，但$()更方便嵌套使用

反撇号``：将命令的执行输出作为变量值



read标准输入取值

从键盘读入变量值完成赋值

格式：read [-p ”提示信息“] 变量名

-p 可选 ，-t 可指定超时秒数



终端显示控制

stty -echo：关闭终端输出(无显示)

stty echo：恢复终端输出(显示)



变量的作用范围

局部变量：新定义的变量默认只在当前shell环境中有效，无法在子shell环境中使用

全局变量：全局变量在当前shell及子shell环境中均有效，使用export可将局部变量声明为全局变量

export 局部变量名[=变量值] ：为局部变量添加全局属性

export -n 全局变量名 ：取消指定变量的全局属性



## 数值运算 ##

基本运算类别

四则运算

​				加法：num1 + num2 

​				减法：num1 - num2 

​				乘法：num1 * num2 

​				除法：num1 / num2

取余数运算

​				求模：num1 % num2



expr运算工具

计算指定的表达式，并输出结果

​				格式：expr 整数1 运算符 整数2

​				乘法操作应采用 \ * 转义，避免被作为shell通配符

| 类型   | 运算符 | 示例                                  |
| ------ | ------ | ------------------------------------- |
| 加法   | +      | expr 43 + 21 、expr $x + $y           |
| 减法   | -      | expr 43 - 21 、expr $x - $y           |
| 乘法   | \ *    | expr 43 \ * 21 、expr $x \ * xy       |
| 除法   | /      | expr 43 / 21 、expr $x / expr $y      |
| 取余数 | %      | expr 43 % expr 21 、expr $x % expr $y |



$[]算式替换

使用$[]或$(())表达式

格式：$[整数1 运算符 整数2 ...]

乘法操作*无需转义，运算符两侧可以无空格

引用变量可省略$符号            

计算结果替换表达式本身，可结合echo命令输出



变量的自增/减等操作

使用$[]替换，或者let命令来完成

| 简写表达式 | 完整表达式 |
| :--------: | :--------: |
|    i++     |   i=i+1    |
|    i--     |   i=i-1    |
|    i+=2    |   i=i+2    |
|    i-=2    |   i=i-2    |
|    i*=2    |   i=i*2    |
|    i/=2    |   i=i/2    |
|    i%=2    |   i=i%2    |



小数运算

使用bc实现小数计算

设置scale=n 可约束小数位

bc 			#打开计算器程序

12.34 * 56.78 #提交表达式

quit			#退出计算器



结合管道向bc发送表达式

echo ""   		|   bc  					#支持多项 中间用“;”



小数值的比较

用法：echo “数值1”  比较符    “数值2”    |   bc 	#支持变量

如果表达式成立，则返回的计算结果为1，否则为0



## 条件测试 ##

test 测试操作

test 选项 参数 



字符串比较

[操作符 字符串]

| 操作符 | 含义                        |
| ------ | --------------------------- |
| -z     | 字符串的值为空              |
| -n     | 字符串的值不为空(相当于!-z) |
| ==     | 两个字符串相同              |
| !=     | 两个字符串不相同            |

例：

[ -z "" ] && echo yes || echo no

yes

[ -z " " ] && echo yes || echo no 

no

[ $USER == "root" ] && echo “超级用户”

[ $PWD != "/" ] && pwd 

/root

整数值比较

| 操作符 | 含义                         |
| ------ | ---------------------------- |
| -eq    | 等于(equal)                  |
| -ne    | 不等于(not equal)            |
| -ge    | 大于或等于(greater or equal) |
| -le    | 小于或等于(lesser or equal)  |
| -gt    | 大于(greater than)           |
| -lt    | 小于(lesser than)            |

例：检查已登录的用户数，是否不超过五个

[ $(who | wc -l ) -le 5 ] && echo "ok"

ok



文件状态测试

[ 操作符 文件或目录 ]

| 操作符 | 含义                                       |
| ------ | ------------------------------------------ |
| -e     | 判断对象是否存在(exist)，若存在则结果为真  |
| -d     | 判断对象是否为目录(directory)，是则为真    |
| -f     | 判断对象是否为文件(file)，是则为真         |
| -r     | 判断对象是否有可读(read)权限，是则为真     |
| -w     | 判断对象是否有可写(write)权限，是则为真    |
| -x     | 判断对象是否有可执行(excute)权限，是则为真 |

例：

[ -d /etc/hosts ]

echo $?

1



组合多个条件

逻辑分割操作

命令1 操作符 命令2 

[ 条件1 ] 操作符 [ 条件2 ]

| 操作符 | 含义                                     |
| ------ | ---------------------------------------- |
| &&     | 给定条件必须都成立，整个测试结果才为真   |
| \|\|   | 只要其中一个条件成立，则整个测试结果为真 |

三个条件时
前面是&& 后面&&前面全成功才成功  
后面|| 前面成功一个算成功
前面是||  后面&&前面成功一个算成功
后面|| 前面都失败算失败
; 间隔不同命令 前后没有逻辑关系



例：当前用户为root，且位于/root目录下

[ $USER == "root" ] && [ $PWD  == "/root" ]

[ $? -eq 0 ] && echo yes

yes

当/opt/testdir目录不存在时，创建该目录

[ -d "/opt/testdir" ] || mkdir -p /opt/testdir



## if选择结构 ##

单分支结构：当“条件成立”时执行命令序列，否则不执行任何操作

if 条件测试

​	then 命令序列

fi

例：判断挂载点目录，若不存在则创建

```shell
#!/bin/bash
Mount_dir="/media/cdrom/"
if [ -d Mount_dir ]
then 
	mkdir -p Mount_dir 
fi
```



双分支结构：当“条件成立”时执行命令序列1，否则执行命令序列2

if 条件测试

​	then 命令序列1

​	else 命令序列2

fi 

例：检测并判断指定的主机是否可以ping通，目标主机的地址以位置参数提供

```shell
#!/bin/bash
ping -c 3 -i 0.2 -W 3 $1 &> /dev/null
if [ $? -eq 0 ] ; then
	echo "Host $1 is up"
else 
	echo "Host $1 is down"
fi
```



多分支结构

相当于if语句嵌套，针对多个条件分别执行不同的操作

if 条件测试1

​	then 命令序列1 

elif 条件测试2

​	then 命令序列2

else 命令序列n

fi

例：输入一个分数，判断成绩分档，85~100优秀、70~84良好、低于70分 不及格

```shell
#!/bin/bash
read -p '请输入一个分数(0-100):' FS
if [ $FS -ge 85 ] && [ $FS -le 100 ]; then
	echo "$FS分，优秀！"
elif [ $FS -ge 70 ] && [ $FS -le 84 ]; then 
	echo "$FS分，良好"
else echo "$FS分，不及格"
fi
```



## 循环结构 ##

### for循环 ###

遍历/列表式循环

根据变量的不同取值，重复执行命令序列

for 变量名 in 值列表 

do   

​	命令序列

done 

例：批量添加用户账户

```shell
#!/bin/bash
Ulist = $(cat /root/user.txt)
for uname in $Ulist
do 
	useradd $uname
    echo "123456" | passwd --stdin $uname
done
```

通过变量控制，条件成立时循环，步长可控次数

for ((初值;条件;步长控制))							for ((i=1;i<=5;i+=2))

do 																	do 			

​	命令序列															echo $i	

done 																done

​																	      1   3   5	 		

### while循环 ###

条件式循环：反复测试条件，只要成立就执行命令序列

while 条件测试

do 命令序列

done 

例：批量添加用户(名称有规律)

```shell
#!/bin/bash
Prefix = "tuser"; i = 1
whilt [ $i -le 5]
do 
	useradd ${Prefie}$i
	echo "123456" | passwd --stdin ${Prefix}$i &> /dev/null
	let i++
done 
```



## case语句 ##

case分支结构

case 变量值 in 

模式1)

​	命令序列1;;

模式2)

​	命令序列2;;

*)

​	默认命令序列

esac

例：判断用户输入

```shell
#!/bin/bash
case $1 in 
redhat)
	echo "fedora";;
fedora)
	echo "redhat";;
	*)
    	echo "用法：$0{redhat|fedora}"
esac
```



## Shell函数 ##

在shell环境中，将一些需要重复使用的操作，定义为公共的语句块，即可称为函数

定义函数：

function 函数名 {

​	命令序列

​	... ...

}



调用已定义的函数

格式：函数名

先定义了才能调用，就好比脚本的“内部命令”

函数传值

格式：函数名 值1 值2 

传递的值作为函数的“位置参数”

例：创建一个对2个整数求和的加法器

```shell
function adder{
echo $[$1+$2]
}
adder 12 34 
46
```

新建函数mkcd，用来创建一个目录，并切换到此目录

```shell
mkcd(){
mkdir $1
cd $1
}
```



## 中断及退出 ##

| 类型     | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| break    | 跳出当前所在的循环体，执行循环体后的语句块                   |
| continue | 跳过循环体内余下的语句，重新判断条件以觉得是否需要执行下一次循环 |
| exit     | 退出脚本，默认的返回值是0                                    |

例：从键盘循环取整数(0结束)并求和，输出最终结果

```shell
#!/bin/bash
while 	read -p "请输入整数数字累加(0结束):" x
do [ $x -eq 0 ] && break
 	sum=$[sum+x]
done 
echo "总和为$sum"
```

跳过1~20以内非6的倍数，输出其他数的平方值

```shell
#!/bin/bash
i=0
while [ $i -le 20 ]
do 
	let i++
	[ $[i%6 -ne 0] && continue 
	echo $[i*i]
done
```

利用位置参数获取2个整数，计算出这两个整数的和，如果参数不够两个，则提示正确用法并退出脚本

```shell
#!/bin/bash
if [ $# -ne 2 ] then
	echo "用法：$0 num1 num2"
	exit 10 #退出脚本返回值为10
if 
expr $1 + $2
```



## 字符串处理 ##

### 子串截取  ###

使用${}表达式

${var: 起始位置:长度} 				#编号从0开始，可省略

例：截取变量NM的前6个字符

NM="Tarena IT Group"

echo ${NM:0:6}

Tarena



### 子串替换 ###

只替换第一个匹配结果

格式：${var/old/new}

替换全部匹配结果

格式：${var//old/new}

例：将变量NMd中的a替换为##

echo ${NM/a/##} 	#只替换一个a	T##rena IT Group

echo ${NM//a/##}	#替换掉所有的a T##ren## IT Group



### 按条件掐头去尾 ###

字符串掐头

从左向右，最短匹配删除

格式：${var#*关键词}

从左向右，最长匹配删除

格式：${var##*关键词}

例：

MDIR="/var/spool/mail/root"

echo ${MDIR#*/} 			var/spool/mail/root

echo ${MDIR##*/} 		  root 



字符串去尾

从右向左，最短匹配删除

格式：${var%关键词*}

从右向左，最长匹配

格式：${var%%关键词*}

例：

MDIR="/var/spool/mail/root"

echo ${MDIR%/*}			/var/spool/mail

echo ${MDIR%%/*}		全部删除



脚本示例：实现批量改名，将扩展名.doc改为.txt

```shell
#!/bin/bash
for File in *.doc
do mv $File ${File/.doc/.txt}
done
```



变量初始值处理

取值，${var:-word}

若变量var已存在且非null，则返回$var的值

否则返回字串"word" ，变量var值不变

例：

NM="Tarena IT Group"

echo ${NM:-Tarena}

Tarena IT Group

unset NM

echo ${NM:-Tarena}

Tarena



脚本示例：提示输入一个正整数x，求从1~x的和，若用户为输入值，则赋初值x=1，避免执行出错

```shell
#!/bin/bash
read -p "请输入一个正整数：" x
x=${x:-1};i=1;sum=0
while [ $i -le $x ]
do 
	let sum+=i ;let i++
done 
echo "从1到$x的总和是$sum"
```



## 正则表达式 ##

egrep过滤工具

文本处理顺序：以行为单位，逐行进行处理，默认只输出表达式相匹配的文本行

格式：egrep [选项]  '正则表达式' 文件 ...

格式2：前置命令 | egrep [选项] '正则表达式'



egrep常用选项

-i：忽略字母大小写

-v：条件取反

-c：统计匹配行数

-q：静默、无任何输出，一般用于检测

-n：显示出匹配结果虽在的行号

--color：标红显示匹配字串



基础元字符

行首尾及单子匹配

| 类型 | 含义     | 示例 | 说明                           |
| :--- | -------- | ---- | ------------------------------ |
| ^    | 匹配行首 | ^abc | 以abc开头的行                  |
|      |          | ^#   | 以#号开头的行(比如注释行)      |
| $    | 匹配行尾 | abc$ | 以abc结尾的行                  |
|      |          | ^$   | 空行                           |
| .    | 单个字符 | .    | 除换行符(\n)以外的任意单个字符 |

未定匹配次数

| 类型 | 含义         | 示例   | 说明                 |
| ---- | ------------ | ------ | -------------------- |
| +    | 最少匹配一次 | a+     | 一个或多个连续的a    |
|      |              | (abc)+ | 一个或多个连续的abc  |
| ?    | 最多匹配一次 | a?     | 0个或1个a            |
|      |              | (abc)  | 0个或1个abc          |
| *    | 匹配任意次数 | a*     | 0个或多个连续的a     |
|      |              | (abc)* | 0个或多个连续的abc   |
|      |              | .*     | 任意长度的任意字符串 |

{} 限定表达式的匹配次数

{n}、{n,m}、{n,}

| 类型  | 含义        | 示例      | 说明                  |
| ----- | ----------- | --------- | --------------------- |
| {n}   | 匹配n次     | (ab){3}   | 匹配ababab            |
| {n,m} | 匹配n-m次   | (ab){1,3} | 匹配ab、abab、ababab  |
| {n,}  | 匹配至少n次 | (ab){3,}  | 匹配3个及以上连续的ab |



其他元字符

[]范围内单字匹配：匹配指定字符集合内的任何一个字符

可加^取反

| 示例      | 说明                    |
| --------- | ----------------------- |
| [alc45_?] | 匹配a、l、c、4、5、_、? |
| [a-z]     | 匹配任意小写字母        |
| [A-Z]     | 匹配任意大写字母        |
| [0-9]     | 匹配任意数字            |
| [a-Z0-9]  | 匹配任意字母或数字      |
| [^A-Z]    | 匹配包括非大写字母的行  |
| ^[ ^a-z ] | 匹配不以字母开头的行    |



整体及边界匹配

| 类型 | 含义           | 示例       | 说明                                      |
| ---- | -------------- | ---------- | ----------------------------------------- |
| ()   | 组合为整体     | ab{1,3}    | 匹配ab、abb、abbb                         |
|      |                | (ab){1,3}  | 匹配ab、abab、ababab                      |
| \|   | 或者           | root\|bin  | 匹配root、bin                             |
| \b   | 单词边界       | \broot\b   | 匹配单词root，不匹配keroot、rooty等字符串 |
| \ <  | 单词的开头     | \ <th      | 匹配以th开头的单词                        |
| \ >  | 单词的结束     | \ <root\ > | 作用与\broot\b相同                        |
| \w   | 字母数字下划线 | \wa        | 匹配xz，不匹配#a                          |
| \s   | 匹配空白       | \sa        | 匹配 a，不匹配xa                          |
| \d   | 匹配数字       | -P \da     | 匹配5a，不匹配xa                          |

\为转义符号，可以为一些普通字符赋予特殊含义，或者将一些特殊字符变为普通字符



## sed基本用法 ##

流式编辑器

非交互，基于模式匹配过滤及修改文本

逐行处理，并将结果输出到屏幕

可实现对文本的输出、删除、替换、复制、剪切、导入、导出等各种操作



命令格式：

1、前置命令 | sed 	[选项] 	'编辑指令'

2、sed 	[选项] 	'编辑指令' 	文件   			(编辑指令：[定址符]处理动作)   定址符--[地址1，[地址2]]        



常见命令选项：

-n：屏蔽默认输出(全部文本)

-i：直接修改文件内容

-r：启用扩展的正则表达式，若与其他选项一起使用，应作为首个选项



条件，可以是行号或/正则/

-行号可以使用单个数字表示单行

-或者3，5表示连续的多行

-省略条件，则默认逐行处理全部文本

-匹配正则时，需要使用//

例：

sed -n '2,4p' /etc/passwd 输出第2-4行

sed -n 'p' /etc/passwd 	输出全部

sed -n '/root/p' /etc/passwd 输出包含root的行



常用动作指令：

| 操作符 | 用途       | 指令示例                                |
| ------ | ---------- | --------------------------------------- |
| p      | 打印行     | 2,4p 输出第2、3、4行                    |
|        |            | 2p;4p 输出第2行、第4行                  |
| d      | 删除行     | 2,4d  删除第2、3、4行                   |
| s      | 字符串替换 | s/old/new/    将每行的第1个old替换为new |
|        |            | s/old/new/3  将每行的第3个old替换为new  |
|        |            | s/old/new/g  将所有的old都替换为new     |

替换操作的分隔"/" 可以改用其他的字符，如#、&等，便于修改文件路径



常见操作示例

输出文本

sed -n 'p' a.txt 			输出所有行，等同于cat a.txt

sed -n '4p' a.txt 			输出第4行

sed -n '4,7p' a.txt 		输出第4~7行

sed -n '4,+10p' a.txt 	输出第4行及其后的10行内容

sed -n '/^bin/p' a.txt 	输出以bin开头的行

sed -n '$=' a.txt 			输出文件的行数



删除文本

sed '3,5d' a.txt 			删除第3~5行

sed '/xml/d' a.txt 		删除所有包含xml的行

sed '/xml/!d' a.txt 		删除不包含xml的行

sed '/^install/d' 			删除以install开头的行

sed '$d' a.txt 				删除文件的最后一行

sed '/^$/d' a.txt 			删除所有空行



替换文本

sed 's/xml/XML/' a.txt 		将每行中第一个xml替换为XML

sed 's/xml/XML/3' a.txt 		将每行中第三个xml替换为XML

sed 's/xml/XML/g' a.txt 		将所有的xml替换为XML

sed 's/xml//g' a.txt 				将所有的xml都删除(替换为空)

sed '4,7s/^/#/' a.txt 				将第4~7行注释掉(行首加#号)

sed 's/^#an/an/' a.txt  			解除以#an开头的行的注释(去除行首的#号)

此示例只做输出，不更改源文件，更改加-i选项



### sed应用案例 ###

修改IP配置

修改虚拟机XML文件的名称值<name>

sed -ri '/^IPADDR/s/192.168.1.(.*)/172.168.0.\1/' /etc/sysconfig/network-scripts/ifcfg-eth0

使用\1标签可调用本组表达式内第1个用()保存的匹配结果



修改网站根目录：将/var/www/html/ 修改为/opt/wwwroot

sed -i 's#/var/www/html#/opt/wwwroot#' /etc/httpd/conf/httpd.conf



### sed文本块处理 ###

| 操作符 | 用途         | 指令示例                             |
| ------ | ------------ | ------------------------------------ |
| i      | 行前插入     | 2iYY 在第2行之前添加文本行”YY“       |
|        |              | 4,7iYY 在第4~7行的每一行前添加文本行 |
| a      | 行后插入文本 | 2aYY  在第2行之后添加文本            |
|        |              | /^XX/aYY 在以XX开头的行之后添加文本  |
| c      | 替换当前行   | 2cYY 将第2行的内容修改为"YY"         |



处理多行文本时，以换行符\n分隔，或者，使用\强制换行 

例：sed -n '2cXX\nYY' m.txt

XX

YY

sed -n '2cXX\YY' m.txt

XX

YY



## sed高级应用 ##

文件导入导出

基本动作

-r 动作应结合 -i 选项才会存入，否则只输出

-w  动作以覆盖的方式另存为新文件



| 操作符 | 用途       | 指令示例                            |
| ------ | ---------- | ----------------------------------- |
| r      | 读取文件   | 3r b.txt 在第3行下方插入文件b.txt   |
|        |            | 47r 在第4~7每一行后插入文件b.txt    |
| w      | 保存到文件 | 3w c.txt 将第3行另存为文件c.txt     |
|        |            | 4,7w c.txt 将第4~7行另存为文件c.txt |

例：

sed -n '/^XX/w d.txt' reg.txt == sed -n '/^XX/p' reg.txt > d.txt



### sed流控制 ###

！取反操作

根据定址条件取反

示例：列出不适用bash的用户账号记录

sed -n '/bash$/!p' /etc/passwd 



结合脚本示例

根据/etc/passwd提取密码串：找到使用bash作为登录shell的本地用户，列出这些用户的shadow密码记录，按每行"用户名 --> 密码记录" 保存结果

```shell
#!/bin/bash
touch /tmp/getupwd.log									#创建空文件
sed -n '/:\/bin\/bash$/w /tmp/urec.tmp' /etc/passwd		#提取符合条件的账号记录
Unum=$(egrep -c '.' /tmp/urec.tmp)						#取得记录个数
while [ ${i:=1} -le $Unum ]								#从第一行开始，遍历账号记录
do 																	
	Urec=$(sed -n "${i}p" /tmp/urec.tmp)				#取指定行数的记录
	Name=${Urec%%:*}									#截取用户名(记录去尾)
	Prec=$(sed -n "/^$Name:/p" /etc/shadow)				#查找与用户名对应的shadow记录
	Pass=${Prec#*:}										#掐头			
    Pass=${Pass%%:*}									#去尾，只留密码记录
    echo "$Name --> $Pass" >> /tmp/getupwd.log			#保存结果
	let i++
done 
/bin/rm -rf /tmp/urec.tmp								#删除临时文件
echo "用户分析完毕，请查阅 /tmp/getupwd.log"
```



## awk基本用法 ##

awk编程语言/数据处理引擎

基于模式匹配检查输入文本，逐行处理并输出

通常用在shell脚本中，获取指定的数据

单独用时，可对文本数据做统计

格式：awk [选项] '[条件] {编辑指令}' 文件 

1：前置命令  |    awk [选项] '[条件] {指令}'

2：awk [选项]  '[条件] {指令}'  文件



常用命令选项：

-F：指定分隔符，可省略(默认空格或Tab为)



检查登录失败的IP地址有哪些

awk '/Failed/{print $11}' /var/log/secure



检查内存的剩余容量

free | awk '/Mem/{print $4}'



过滤网络流量

ifconfig eth0 | awk '/RX p/{print $5}'



awk内置变量

|      | 用途                                            |
| ---- | ----------------------------------------------- |
| FS   | 保存或设置字段分隔符，例如FS=“:”，与-F功能一样  |
| $n   | 指定分隔的第n个字段，如$1、$3分别表示第1、第3列 |
| $0   | 当前读入的整行文本内容                          |
| NF   | 记录当前处理行的字段个数(列数)                  |
| NR   | 记录当前已读入行的数量(行数)                    |

示例：

awk -F: '{print "用户名:",$1,"解释器:",$7}' /etc/passwd



awk过滤的时机(可单独使用，也可以同时一起使用)

- 在所有行前处理，BEGIN{}

  读入第一行文本之前执行

  一般用来初始化操作

- 逐行处理，{}

  逐行读入文本执行相应的处理

  是在常见的编辑指令块

- 在所有行后处理，END{}

  处理完成最后一行文本之后执行

  一般用来输出处理结果



示例：

awk 'BEGIN{x=0}/\<bash$/{x++}END{print x}' /etc/passwd 			#统计使用bash的用户个数



条件设置示例

/正则表达式/

~匹配、!~不匹配  



数值比较

==等于、!=不等于

">"大于、">="大于或等于

"<"小于、"<="小于或等于



多个条件的组合

逻辑比较测试

&&逻辑与：期望多个条件都成立

||逻辑或：只要一个条件成立即满足要求



变量的运算

运算符：+、-、*、/、%，++、--、+=、-=、*=、/=



示例：

列出以ro开头的用户记录

awk -F: '/^ro/{print}' /etc/passwd 



列出第7个字段不以bash结尾的用户名，登录shell

awk -F: '$7!~/bash$/{print $1,$7}' /etc/passwd



输出第2行文本

awk 'NR==2 {print}' 文本



输出第2列不是XX的行

awk '$2!="XX"{print}' 文本



输出包含2个及以上字段的行

awk 'NF>=2 {print}' 文本



列出UID小于2的用户信息

awk '$3>=0&&$3<2{print $1,$3}' /etc/passwd



列出UID为1或7的用户信息

awk -F: '$3==1||$3==7{print $1,$3}' /etc/passwd



输出奇数行文本

awk 'NR%2==1{print}' 文本



统计文本的总字段数

awk 'BEGIN{x=0}{i+=NF}END{print i}' 文本



计算能同时被3和13整除的整数个数

seq 200 | awk 'BEGIN {i=0} ($0%3)==0&&($0%13==0){i++}END{print i}'



## awk高级应用 ##

awk流程控制

分支结构

单分支：if(条件){编辑指令}

双分支：if(条件){编辑指令1}else{编辑指令2}

多分支：if(条件){编辑指令1}else if(条件){编辑指令2}...else {编辑指令N}



示例：统计UID小于或等于500的用户个数，统计UID大于500的用户个数

awk -F: 'BEGIN{i=0;j=0}{if($3<=500){i++}else{j++}}END{print i,j}' /etc/passwd



### awk数组 ###

定义数组

格式：数组名[下标]=元素值

调用数组

格式：数组名[下标]

遍历数组

用法：for(变量 in 数组名){print 数组名[变量]}



示例：为数组name赋值两个元素，值分别为jim、tom

awk 'BEGIN{name[0]="jim";name[1]="tom";print name[0],name[1]}'



针对web访问日志计算访问量排名

获得结果：客户机的地址、访问次数，按照访问次数排名

以$1做下标，定义数组ip，最后利用for循环输出数组下标，对应数组元素的值

awk '{ip[$1]++}END{for (i in ip){print ip[i],i}}' /var/log/httpd/access_log



利用sort对提取结果排序

sort -n：按数字升序排列，-k：针对指定的列进行排序，-r：反向排序

awk '{ip[$1]++}END{for (i in ip){print ip[i],i}}' /var/log/httpd/access_log | sort -nr



监控脚本

任务需求：编写脚本监控本机各项数据指标(CPU负载，网卡流量，内存剩余容量，磁盘剩余容量，计算机账户数量，当前登录账户数量，计算机当前开启的进程数量，本机已安装的软件包数量)

uptime，ifconfig，free，df，cat /etc/passwd，ps aux，rpm -qa

```shell
#!/bin/bash
ip=`ifconfig eth0 | awk '/inet/{print $2}'`
echo "本地IP地址是:"$ip
cpu=`uptime | awk '{print $NF}'`
echo "本机cpu最近15分钟的负载是"$cpu
net_in=`ifconfig eth0 | awk '/RX p/{print $5}'`
echo "入站网卡流量为:"$net_in
net_out=`ifconfig eth0 | awk '/TX p/{print $5}'`
echo "出站网卡流量为:"$net_out
mem=`free | awk '/Mem/{print $4}'`
echo "内存剩余容量为:"$mem
disk=`df | awk '/\/$/{print $4}'`
echo "根分区剩余容量为:"$disk
user=`cat /etc/passwd | wc -l`
echo "本地账户数量为"$user
login=`who | wc -l`
echo "当前登录计算机的账户数量为"$login
soft=`rpm -qa | wc -l`
echo "当前计算机已安装的软件数量为"$soft
```



安全检测脚本

任务需求：防止远程ssh暴力破解密码，检测ssh登录日志，如果远程登陆账号名错误3次，则屏蔽远程主机的IP、检测ssh登录日志，如果远程登录密码错误3次，则屏蔽远程主机的IP

```shell
#!/bin/bash
awk '/Failed password/{print $11}' /var/log/secure | awk '{ip[$1]++}END{for (i in ip){print ip[i],i}}' | awk '$1>3{print $2}'
awk '/Invaid user/{print $10}' /var/log/secure | awk '{ip[$1]++}END{for (i in ip){print ip[i],i}}' | awk '$1>3{print $2}'
```



# Operation(Linux高级运维) #

## Nginx安装部署 ##

是俄罗斯人编写的十分轻量级的HTTP服务器

一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP代理服务器

官方站点：http://nginx.org/



Nginx软件安装

```shell
yum -y install gcc pcre-devel openssl-devel
useradd nginx
tar -zxvf nginx-1.12.2.tar.gz
cd nginx-1.12.2
./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_ssl_module
make && make install
```



Nginx进程管理

/usr/local/nginx/sbin/nginx

常用选项： -V：查看编译参数 		-c：指定配置文件，启动服务



查看服务相关进程及端口信息

ps aux | grep nginx

netstat -anutlp | grep nginx



### Nginx配置解析 ###

配置文件结构

全局配置

http{

 ... ...

​			server {												#定义虚拟主机		

​							listen 80;

​							server_name localhost;

​							location /{							#发布目录

​									root html;

​									index index.html index.html;

​								   auth_basic "auth-domain";								#用户认证

​								   auth_basic_user_file /usr/local/nginx/pass;	#用户认证

​							}

​			}

}



### 三种模式的虚拟主机 ###

基于域名的虚拟主机

server {

​			server_name web1.abc.com;

}	

基于端口的虚拟主机

server {

​			listen 8080;

​			server_name web1.abc.com;

}

基于IP的虚拟主机

server {

​			listen 192.168.1.10:80;

​			server_name web1.abc.com;

}



### HTTPS加密网站 ###

对称密钥

AES DES 			应用案例：RAR、ZIP压缩加密(单机加密)

非对称加密

RSA DSA 		   应用案例：网络加密(https、ssh)

信息摘要 

MD5、sha512  应用案例：数据完整性校验



SSL虚拟主机

生成密钥

```shell
cd /usr/local/nginx/conf/
openssl genrsa > cert.key 2048							#生成私钥
openssl req -new -x509 -key cert.key > cert.pem			#生成证书
```

ssl加密网站

修改配置文件/usr/local/nginx/conf/nginx.conf

```shell
server {
		listen 443 ssl;							#开启SSL
		ssl_certificate cert.pem;				#指定证书文件
		ssl_certificate_key cert.pem;			#指定私钥文件
		ssl_protocols SSLv2 SSLv3 TLSv1;
		ssl_ciphers HIGH:!aNULL:!MD5;
		ssl_prefer_server_ciphers on;
		
}
```



## 部署LNMP ##

L：Linux操作系统

N：Nginx网站服务软件

M：Mysql、MariaDB数据库

P：网站开发语言(PHP、Perl、Python)



### 安装 ###

Nginx

```shell
tar -zxvf nginx-1.12.2.tar.gz
cd nginx-1.12.2
./configure --prefix=/usr/local/nginx --with-http_ssl_module
make && make install
```



MariaDB

```shell
yum -y install mariadb-server
yum -y install mariadb
yum -y install mariadb-devel
```



PHP

```shell
yum -y install php
yum -y install php-fpm
yum -y install php-mysql 				#给PHP安装扩展库文件，使得PHP可以连接MariaDB数据库
```



### 启动服务 ###

Nginx

```shell
/usr/local/nginx/sbin/nginx
netstat -anutlp | grep :80
```

MySQL

```shell
systemctl start mariadb
systemctl status mariadb
netstat -anutlp | grep :3306
```

PHP

```shell
systemctl start php-fpm
systemctl status php-fpm 
netstat -anutlp | grep :9000
```



### Nginx+FastCGI ###

FastCGI工作流程

1.Webserver 启动时载入FastCGI进程管理器

2.FastCGI进程管理器初始化，启动多个解释器进程

3.当客户端请求到达Webserver时，FastCGI进程管理器选择并连接到一个解释器

4.FastCGI子进程完成处理后返回结果，将标准输出和错误信息从同一连接返回Webserver



FastCGI缺点：内存消耗大(因为是多进程) Nginx+PHP服务器在3万并发连接下：开10个Nginx进程消耗150M内存(10x15M) 开64个php-cgi进程消耗1280M内存(20Mx64)



配置FastCGI

```shell
vim /etc/php-fpm.d/www.conf
[www]
listen=127.0.0.1:9000
```



Nginx配置

编辑nginx.conf

```shell
vim /usr/local/nginx/conf/nginx.conf
location ~ \.php$ {
		root html;
		fastcgi_pass 127.0.0.1:9000;			#php-fph的IP与端口
		fastcgi_index index.php;
		include fastcgi.conf;					#加载fastcgi参数文件
}
```



测试

创建PHP首页index.php，测试效果

```shell
vim /usr/local/nginx/html/index.php
<?php
$i=33;
echo $i;
?>
```

创建PHP页面，测试数据库连接效果

```shell
vim /usr/local/nginx/html/mysql.php
<?php
$mysqli=@new mysqli('localhost','root','mysql');
//主机名，用户名，密码，数据库
if ($mysqli->connect_errno){
	die('Connect Error:'.$mysqli->connect_errno);
}
else {
			echo "link db OK!";
}
```

创建PHP页面，测试数据库连接效果

```shell
vim /usr/local/nginx/html/mysql.php
<?php
$mysqli=new mysqli('localhost','root','mysql');
if (mysqli_connect_errno()){
			die('Unable to connect!').mysqli_connect_error();
}
$sql="select * from user";
$result=$mysqli->query($sql);
while ($row=$result->fetch_array()){
	printf("Host:%s",$row[0]);
	printf("</br>");
	printf("Nmae:%s",$row[1]);
	printf("</br>");
}
?>
```



## Nginx高级技术 ##

地址重写

获得一个来访的URL请求，然后改写成服务起可以处理的另一个URL的过程

好处：缩短URL，隐藏实际路径提供安全性，易于用户记忆和键入，易于被搜索引擎收录



rewrite语法

rewrite regex(旧地址) replacement(新地址) flag(选项)

if (条件) {...}



应用案例：a.html --> b.html

```shell
location / {
	rewrite /a.html /b.html;
}
```

域名跳转：www.tarena.com --> bbs.tarena.com

```shell
server {
	server_name www.tarena.com;
location /{
	rewrite ^/(.*) http://bbs.tarena.com/$1;
}
}
```

根据浏览器返回不同的页面

```shell
server {
location / {
}
if ($http_user_agent ~ firefox) {
rewrite ^(.*)$ /firefox/$1 break;
}
}
```

正则表达式匹配模式：

区分大小写匹配：~

不区分大小写匹配：~*

区分大小写不匹配：!~

不区分大小写不匹配：!~*



rewrite选项

rewrite regex replacement flag 

flag：break、last、redirect、permanent

last：停止执行其他重写规则，地址栏不改变

break：停止执行其他的重写规则，完成本次请求

redirect：302临时重定向，地址栏改变，爬虫不更新URL

permanent：301永久重定向，地址栏改变，爬虫更新URL



## Nginx调度器 ##

HTTP调度

Nginx反向代理语法格式：

```shell
http {
	upstream sergrp{
		server 192.168.8.5:80;				#定义源服务器组
		server 192.168.8.6:80;
	server {
			listen 80;
			server_name www.tarena.com;		#web主机名
			location /{
				proxy_pass http://sergrp;	#调用服务器
			}
	}
	}
}
```



Nginx调度算法

轮询(默认的)：逐一循环调度

weight：指定轮询几率，权重值和访问比率成正比

ip_hash：根据客户端IP分配固定的后端服务器



服务器组主机状态

down：表示当前server暂时不参与负载

max_fails：允许请求失败的次数(默认为1)

fail_timeout：max_fails次失败后，暂停提供服务的时间



示例：

```shell
upstream sergrp{
	#ip_hash
	#server 192.168.8.5:80 weight=2
	server 192.168.8.5:80 down;
	server 192.168.8.4:80 max_fails=2 fail_timeout=30;
}
```



### TCP/UDP调度 ###

模块 

ngx_stream_core_module模块

使用--with-stream开启该模块

从nginx1.9版本才支持



语法格式

```shell
stream {
		upstream backend {
			server backend1.example.com:12345 weight=5;
			server 127.0.0.1:22 max_fails=3 fail_timeout=30s;
		}
		server {
			listen 12345;
			proxy_pass backend;
		}
}
http {

}
```



## Nginx优化 ##

HTTP错误代码

常见错误代码

| 返回码 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| 200    | 一切正常                                                     |
| 400    | 请求语法错误                                                 |
| 401    | 访问被拒绝(账户或密码错误)                                   |
| 403    | 资源不可用，通常由于服务器上文件或目录的权限设置导致         |
| 403    | 禁止访问：客户端的IP地址被拒绝                               |
| 404    | 无法找到指定位置的资源(Not Found)                            |
| 414    | 请求URL头部太长                                              |
| 500    | 服务器内部错误                                               |
| 502    | 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答(Bad Gateway) |



### 自定义404错误页面 ###

```shell
http{
fastcgi_intercept_errors on; 				#错误页面重定向
server{
error_page 404 /40x.html;					#自定义错误页面
error_page 500 502 503 504 /50x.html;
	location = /50x.html{
		root html;
	}
}
}
```



### Nginx状态页面 ###

status模块

--with-http_stub_status_module开启模块功能

可以查看nginx连接数等信息



修改配置文件

```shell
location /status{
		stub_status on;
}
```

状态信息

Active connections -当前活动的连接数量

Accepts -已经接受客户端的连接总数量

Handled -已经处理客户端的连接总数量(一般与accepts一致，除非服务起限制了连接数量)

Requests -客户端发送的请求数量

Reading -当前服务器正在读取客户端请求头的数量

Writing -当前服务器正在写响应信息的数量

Waiting -当前多少客户端在等待服务器的响应



### 配置优化 ###

常用压力测试工具

ab -c 并发数 -n 总请求数 URL

其他常见的压力测试软件(需要额外下载)：http_load、webbench、siege



全局配置优化

调整进程数量(/usr/local/nginx/conf/nginx.conf)

```shell
#user nobody;
worker_processes 2;				#与CPU核心数量一致
```



EVENT模块优化

max_clients=worker_processes* worker_connections

修改(/usr/local/nginx/conf/nginx.conf)

```shell
events {
		worker_connections 10000;				#每个worker最大并发连接数
}
```

注意修改系统ulimit限制/etc/security/limits.conf 

```shell
* soft nofile 数字			#软限制 用户或组    硬限制或软限制    需要限制的项目    限制的值
* hard nofile 数字			#硬限制
```



命令行配置(临时修改)

ulimit -a 查看linux系统的硬件限制信息

ulimit -n (查看linux系统允许同时开启文件数量)

ulimit -Hn 数字 (修改硬限制)

ulimit -Sn 数字 (修改软限制)



HTTP模块优化

客户端浏览器缓存数据

```shell
location ~*\.(jpg|jpeg|gif|png|css|js|ico|xml)${
		expires 30d;
}
```

解决客户端访问头部信息过长的问题

```shell 
client_header_buffer_size 1k;	#默认请求包头信息的缓存
large_client_header_buffers 4 4k; #大请求包头部信息的缓存个数与容量
```



## Session与Cookie ##

Session存储在服务器端，保存用户名、登陆状态等信息

Cookies由服务器下发给客户端，保存在客户端的一个文件里。保存的内容主要包括：SessionID



本地Session

部署Nginx调度器

```shell
yum -y install gcc pcre pcre-devel openssl-devel 
tar -zxvf nginx-1.12.2.tar.gz
cd nginx-1.12.2
./configure
make && make install

yum -y install memcached		#安装memcached软件
```



修改配置文件

```shell
upstream webs {
		server 192.168.2.100:80;
		server 192.168.2.200:80;
}
	server{
		location / {
			proxy_pass http://webs;
		}
	}
```



启动服务

```shell
/usr/local/nginx/sbin/nginx
```



部署后端LNMP主机

```shell
yum -y install pcre pcre-devel openssl-devel 
tar -zxvf nginx-1.12.2.tar.gz
cd nginx-1.12.2
./configure
make && make install
```



MariaDB

```shell
yum -y install mariadb mariadb-server mariadb-devel
```



PHP

```shell
yum -y install php php-mysql php-pecl-memcache
rpm -ivh php-fpm
```



启动服务

```shell
systemctl restart php-fpm
systemctl restart mariadb
```



在后端LNMP主机操作

```shell
cd lnmp-soft/php-scripts/session/
tar -xf php-memcached-demo.tar.gz
cp * /usr/local/nginx/html
```



验证Session

```shell
ls /var/lib/php/session
```



### 部署memcached ###

数据存储对比

性能 -cpu缓存>内存>磁盘>数据库

价格 -cpu缓存>内存>磁盘>数据库



memcached是高性能的分布式缓存服务器

用来集中缓存数据库查询结果，减少数据库访问次数，以提高动态web应用的想用速度



安装memcached

```shell
yum -y install memcached telnet
rpm -qa memcached
memcached-1.4.15-10.el7_3.1.x86_64
```



启动memcached

```shell
cat /etc/sysconfig/memcached
PORT="11211"						#端口
USER="memcached"					#用户
MAXCONN="1024"						#最大连接数
CACHESIZE="64"						#缓存大小(存储数据)默认64M

/usr/lib/systemd/system/memcached.service 
[Service]
Type=simple
EnvironmentFile=/etc/sysconfig/memcached
ExecStart=/usr/bin/memcached -u $USER -p $PORT -m $CACHESIZE -c $MAXCONN $OPTIONS
[Install]
WantedBy=multi-user.target

systemctl start memcached
sustemctl status memcached
```

使用telnet工具检测memcached是否可用

telnet ip 11211

add 	myname 0 180 10 						#新建，myname不存在则添加，存在则报错(0表示不压缩，180为数据缓存时间，3为需要存储的数据字节数量)

set 							 									#添加或替换变量

replace 														#替换，如果myname不存在则报错(格式和add一样)

get 																#读取

delete 					  									#删除

flush_all														#清空所有

quit																#退出登录



### PHP+memcache ###

部署LNMP

PHP无法直接操作memcached，需要安装memcache扩展



```shell
yum -y install php-pecl-memcache
systemctl restart php-fpm
```



编写php页面

```shell
vim /usr/local/nginx/html/test.php

```



### Session共享 ###

修改PHP配置文件

```shell
vim /etc/php-fpm.d/www.conf
php_value[session.save_handler]=memcache
php_value[session.save_path]="tcp://192.168.2.5:11211"
```



重启服务

systemctl restart php-fpm



## Tomcat服务器 ##

Java：是一种跨平台的、面向对象的程序设计语言，java技术具有卓越的通用性、高效性、平台移植性和安全性

Java体系：Java SE(标准版) 、Java EE(企业版)



JDK：是Sun针对Java开发者推出的Java语言的软件开发工具包

JDK是整个Java的核心

包括了Java运行环境

Java工具(如编译、排错、打包等工具)

Java基础的类库



JRE：java运行环境，JRE是JDK的子集

JRE包括：-Java虚拟机(jvm)、java核心类库和支持文件、不包含开发工具(JDK)--编译器、调试器和其它工具



Java Servlet

Servlet是java扩展Web服务器功能的组件规范

常见Servlet容器

IBM ---websphere

Oracle ---weblogic

Apache ---tomcat

RedHat ---Jboss



### 安装Tomcat  ###

安装部署JDK

```shell
yum -y install java-1.8.0-openjdk

```

安装部署Tomcat

```shell
tar -zxvf apache-tomcat-8.0.30.tar.gz
mv apache-tomcat-8.0.30 /usr/local/tomcat
ls /usr/local/tomcat
bin/		#主程序目录
lib/		#库文件目录
logs/		#日志目录
temp/		#临时文件
work/		#自动编译目录
conf/		#配置文件目录
webapps/	#页面目录
```

启动tomcat

```shell
/usr/local/tomcat/bin/startup.sh
```

生成测试页面

```shell
vim /usr/local/tomcat/webapps/ROOT/test.jsp
<html>
<body>
<center>
Now time is:<%=new java.util.Date()%>
</center>
</body>
</html>
```

访问:8080端口/test.jsp



### Tomcat应用案例 ###

tomcat虚拟主机

主配置文件解析

```shell
server.xml配置文件框架
<?xml version='1.0' encoding='utf-8'?>
<Server port="8005" shutdown="SHUTDOWN">
<Service name="Catalina">
<Connector port="8080" protocol="HTTP/1.1"
		connectionTimeout="20000"
		redirectPort="8443" />
<Connector port="8009" protocol="AJP/1.3" redirectPort="8443" />
<Engine name="Catalina" defaultHost="localhost">
<Host name="localhost" appBase="webapps"
		unpackWARs="true" autoDeploy="true">
</Host>
</Engine>
</Service>
</Server>
#appBase定义基础目录，基础目录下可以有很多项目，默认项目ROOT
#docBase定义首页路径，默认为ROOT
```

基于域名的虚拟主机

修改server.xml文档，给host添加context

```shell
#vim /usr/local/tomcat/conf/server.xml
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
<Context path="/test" docBase="/var/www/html/" />
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true"> </Host>
# echo "test" > /var/www/html/index.html
# /usr/local/tomcat/bin/shutdown.sh
# /usr/local/tomcat/bin/startup.sh
//path指定用户访问的URL,docBase指定页面存储的位置
验证:http://ip:8080/test/
```

工作原理：Context path ---> Host ---> Engine ---> server / service ---> connector(8080、8009)



SSL加密站点

生成私钥证书文件

```shell
#keytool -genkeypair -alias tomcat -keyalg RSA -keystore /usr/local/tomcat/keystore
```

修改server.xml配置文件

```shell
#vim /usr/local/tomcat/conf/server.xml
...
<Connector port="8443"
protocol="org.apache.coyote.http11.Http11NioProtocol"
maxThreads="150" SSLEnabled="true" scheme="https" secure="true
keystoreFile="/usr/local/tomcat/keystore" keystorePass="123456">
clientAuth="false" sslProtocol="TLS"/>
```

测试：https://localhost:8443 https://www.a.com:8443



日志

```shell
#虚拟主机创建独立日志文件
vim /usr/local/tomcat/conf/server.xml
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
	<Context path="/test" docBase="base" />
	<Valve className="org.apache.catalina.valves.AccessLogValve"		#开启日志功能
		prefix="wwwacom_access_log." suffix=".txt" pattern="common" />	#设置日志名
</Host>
```



Tomcat集群

Nginx反向代理tomcat

修改nginx配置

```shell
#vim /usr/local/nginx/conf/nginx.conf
http {
		upstream toms{
				server 192.168.2.100:8080;
				server 192.168.2.200:8080;
		}
		server {
				listen 80;
				server_name localhost;
				location / {
						proxy_pass http://toms;
				}
		}
}
```



### Varnish代理服务器 ###

Proxy，代理人、经纪人、中介

代替用户处理事务：能提供正常情况下不便或无法访问的资源

应用场景：Web访问加速(正/反向)、IP伪装、"翻墙"

代理服务器工作机制：Cache池的复用、线路转移



varnish服务器：高性能且开源的反向代理服务器

#### 部署Varnish ####

```shell
#编译安装
yum -y insatll gcc readline-devel ncurses-devel pcre-devel 
useradd -s /sbin/nologin varnish 
tar -xf varnish-5.2.1.tar.gz
cd varnish-5.2.1
./configure 
make && make install
cp /etc/example.vcl /usr/local/etc/default.vcl
ls /usr/local/sbin/
varnishd
```



#### 加速服务器 ####

```shell
#修改配置文件
vim /usr/local/etc/default.vcl
backend default{
	.host="192.168.2.100";		#后端服务器IP地址
	.port="80";
}
```



启动服务

```shell
varnishd -f /usr/local/etc/default.vcl
```



其他选项

```shell
#varnishd -s malloc,128M
#定义varnish使用内存作为缓存，空间为128M
#varnishd -s file,/var/lib/varnish_storage.bin,1G
#定义varnish使用文件作为缓存
```



缓存管理

```shell
#清除缓存内容的命令格式
varnishadm 
>ban req.url ~.*
```



Varnish日志

```shell
varnishlog [-w file] #共享内存的日志
varnishncsa [-w file] #类Apache日志
```



## Git版本控制 ##

版本库：典型的客户/服务器系统

-版本库是版本控制的核心

-任意数量客户端

-客户端通过写数据库分享代码



分布式版本控制

集中式版本控制系统：开发者之间共用一个仓库(repository)、所有操作需要联网

分布式版本控制系统：每个开发者都是一个仓库的完整克隆，每个人都是服务起、支持断网操作



Git基本概念

Git仓库：保存所有数据的地方

工作区：从仓库中提取出来的文件，放在磁盘上供你使用或修改

暂存区：就是一个文件，索引文件，保存了下次将提交的文件列表信息



工作流程： 1.clone数据到本地 2.修改后add提交暂存区 3.commit提交Git仓库 4.push提交远程服务器



版本控制软件

集中式版本控制软件：CVS、SVN(subversion)

分布式和版本控制软件：Git、BitKeeper(收费)



### Git基本操作 ###

#### 服务器设置 ####

安装Git

```shell
yum -y install git 
```



创建服务器版本仓库

init初始化是一个空仓库(没有具体数据)

```shell
mkdir -p /var/lib/git
git init /var/lib/git/project --bare
ls /var/lib/git/project
config description HEAD hooks info objects refs
```



#### 客户端操作 ####

客户端访问方式

本地访问：git clone file:///var/lib/git/

远程ssh访问：git clone root@服务器IP:/var/lib/git

Web：服务器需要额外配置Web服务器，客户端可以浏览器访问

git clone http://服务器IP/git仓库

Git clone https://服务器IP/git仓库



客户端命令行工具

git支持的子命令操作：

clone 将远程服务器的仓库克隆到本地

config 修改git配置

add 添加修改到暂存区

commit 提交修改到本地仓库

push 提交修改到远程服务器



clone克隆服务器仓库到本地

```shell
yum -y install git 
git clone root@服务器IP:/var/lib/git/project
ls 
anaconda-ks.cfg git
```



config修改git配置

—客户端用户标记信息(跟git账户和密码无关)

```shell
git config --global user.email "you@example.com"
git config --global user.name "your name"
cat .gitconfig
[user]
		email = you@example.com
		name = your name 
```



导入数据，add提交本地暂存区

提示：必须进入工作目录git操作

```shell
cd git
echo "hello" > test.txt
mkdir demo 
cp /etc/hosts demo/
git status 
git add .
```



commit提交本地仓库

```shell
git commit -m "注释"
git status
```



push将本地修改提交远程服务器仓库

```shell
git config --global push.defaults simple
git push 
git status
```

从远程下载使用git pull 命令



log查看历史操作

```shell
git log
git log --pretty=oneline 
git reflog					#方便后期回滚数据
```



### Git进阶 ###

#### HEAD指针 ####

一个可以在任何分支和版本移动的指针

通过移动指针我们可以将数据还原至任何版本



移动HEAD指针

先使用log指令查看版本信息

```shell
git log --pretty=oneline
```

我们需要回到bdbe26这个版本

```shell
git reset --hard bdbe26
```

在使用ls查看当前目录的资料已经还原



使用HEAD^将版本回滚一个版本

```shell
git reset --hard HEAD^
```

使用HEAD^数字，可以将版本回归n个版本

```shell
git reset --hard HEAD~2
```

默认log仅显示当前到之前的版本信息 --all查看所有

```shell
git log --all --pretty=oneline
```



#### Git分支 ####

分支可以让开发分多条主线同时进行，每条主线互不影响

-按功能模块分支、按版本分支

-分支也可以合并



常见的分支规范

-MASTER分支(master是主分支，是代码的核心)

-DEVELOP分支(develop最新开发成果的分支)

-RELEASE分支(为发布新产品设置的分支)

-HOTFIX分支(为了修复软件BUG缺陷的分支)

-FEATURE分支(为开发新功能设置的分支)



管理多分支

查看当前分支

```shell
git status 
git branch -v
```

创建分支

```shell
git branch hotfix 
git branch feature 
git branch -v
```

切换分支

```shell
git checkout hotfix
git branch -v
```

在新的分支上就可以继续修改代码(正常add,commit提交版本库)



将hotfix合并到master分支

合并前，一定要切换到master分支

执行merge命令合并分支

```shell
git checkout master 
git merge hotfix
```



解决分支冲突：修改了不太分支中相同文件的相同行(系统无法合并分支，产生了冲突)

```shell
git checkout hotfix 		#切换至hotfix分支
vim 文件					   
git add 文件				   #修改文件并提交
git commit -m "hotfix"
git checkout master 
vim 文件
git add 文件
git commit -m "hotfix"
git merge hotfix #合并时冲突
```

查看有冲突的文件

直接修改有冲突的文件，修改为最终需要的文件内容，修改完成，add，commit，解决冲突



### Git服务器 ###

ssh协议：密码认证访问

-服务器安装git 

-使用git命令初始化版本仓库

-客户端使用ssh远程访问(可读写权限)

```shell
git init /var/lib/git/test --bare 
git clone root@服务器IP:/var/lib/git/test
```



免密码远程Git服务器

```shell
#客户端生成ssh密钥
ssh-keygen -f /root/.ssh/id_rsa -N ''
#将密钥拷贝给Git服务器
ssh-copy-id git服务器IP
#测试上传、上传代码到远程服务器
git clone root@服务器IP:/var/lib/git/project
git push
```



Git协议

git协议访问支持无授权访问(只读)

```shell
#服务器安装git-daemon软件包
yum -y install git-daemon
#服务器初始化仓库(必须要在/var/lib/git/目录建仓库)
git init --bare /var/lib/git/project
#服务器启动Git服务
systemctl start git.socket
#客户端使用git协议访问(只读)
git clone git://服务器IP/project
```



HTTP协议

```shell
#服务器安装gitweb软件包
yum -y install httpd gitweb
#修改配置文件，设置仓库根目录
vim +11 /etc/gitweb.conf
$projectroot = "/var/lib/git";		#添加一行
#启动httpd服务
systemctl start httpd
```



GitHub (详见PPT)



### RPM打包 ###

打包流程：准备源码软件，安装rpm-build，编写编译配置文件，编译RMP包

```shell
#安装rpm-build
yum -y install rpm-build 
rpm build -ba test.spec #报错，但生成rpmbuild目录

#准备源码软件：将源码包复制到rpmbuild子目录
cp nginx-1.12.2.tar.gz rpmbuild/SOURCES/

#编写编译配置文件
vim /root/rpmbuild/SPECS/nginx.spec
Name:hello			#软件名称
Version:			#软件版本
Release:1			#RPM版本
Summary:			#描述
Group:				#软件组
License:			#协议
URL:				#网址
Source0:			#源码文件
BuildRoot:	%{mktemp -ud %{_tmppath}/%{name}-%{version}-%{release}  #临时编译目录
BuildRequires:		#编译时依赖包
Requires:			#安装时依赖包
%description		#详细描述
%prep				#安装前准备，解压
%setup -q			#系统使用setup自动解压，安静模式
%build				#编译需要执行的命令
make 				
%configure			#配置时需要执行的命令
make %{?_smp_mflags}
%install			#安装时需要执行的指令
rm -rf %{buildroot}
make install DESTDIR=%{buildroot}
%clean				#清理时需要执行的指令
rm -rf %{buildroot}	
%files				#定义打包文件列表
%defattr(-,root,root,-)
%changelog			#软件修改历史

#编译RPM包：使用spec文件编译RPM包
rpmbuild -ba /root/rpmbuild/SPECS/nginx.spec

#安装测试RPM包
rpm -qpi xxx.rpm
rpm -qpl xxx.rpm
rpm -ivh xxx.rpm
```



## VPN服务器 ##

### GRE VPN ###

vpn虚拟专用网络

在公用网络上建立专用私有网络，进行加密通讯

多用于为集团公司的各地子公司建立连接

连接完成后，各个地区的子公司可以像局域网一样通讯、在企业网络中有广泛应用、偶尔可以用于翻墙、目前主流的VPN技术(GRE，PPTP、L2TP+IPSec、SSL)

环境：出差在外，连接公司的服务器，或者，分公司之间的连接



GRE模块：Linux内核模块(ip_gre)

加载模块：

lsmod | grep ip_gre #显示模块列表

modprobe ip_gre #加载模块

modinfo ip_gre #查看模块信息

缺点：缺少加密机制



创建VPN隧道

client

```shell
modprobe ip_gre 
ip tunnel add tun0 mode gre remote 201.1.2.5 local 201.1.2.10
ip link set tun0 up
ip addr add 10.10.10.10/24 peer 10.10.10.5/24 dev tun0
firewall-cmd --set-default-zone=trusted
```

vpn服务器

```shell
modprobe ip_gre
ip tunnel add tun0 mode gre remote 201.1.2.10 local 201.1.2.5
ip link set tun0 up 
ip addr add 10.10.10.5/24 peer 10.10.10.10/24 dev tun0
echo "1" > /proc/sys/net/ipv4/ip_forward
firewall-cmd --set-default-zone=trusted
```

测试连通性

```shell
client
ping 10.10.10.5
ping 192.168.4.5

proxy
ping 10.10.10.10
```



### PPTP VPN ###

支持密码身份验证

支持MPPE加密

环境：使用一台windows主机做为客户端(201.1.2.20/24)

部署VPN服务器

```shell
#安装软件
yum install pptpd-1.4.0-2.el7.x86_64.rpm
rpm -qc pptpd
/etc/ppp/options.pptpd
/etc/pptpd.conf
/etc/sysconfig/pptpd
```

修改配置文件

```shell
vim /etc/pptpd.conf
localip 201.1.2.5				#服务器本地IP
remoteip 192.168.3.1-50			#分配给客户端的IP池

vim /etc/ppp/options.pptpd	
require-mppe-128				#使用MPPE加密数据
ms-dns 8.8.8.8					#DNS服务器

vim /etc/ppp/chap-secrets 		
jacob			*			123456 			*
#用户名		  服务器标记		密码			客户端

echo "1" > /proc/sys/net/ipv4/ip_forward
```

启动服务

```shell
systemctl start pptpd
firewall-cmd --set-default-zone=trusted
```

翻墙设置

```shell
iptables -t nat -A POSTROUTING -s 192.168.3.0/24 -j SNAT --to-source 201.1.2.5
```

windows客户端 图形化配置

设置新的连接或网络 -> 连接到工作区 -> 使用我的Internet连接VPN -> 我将稍后设置Internet连接 

测试:连接到工作区 



### L2TP+IPSec VPN ###

L2TP建立主机之间的VPN隧道，压缩、验证

IPSec提供数据加密、数据校验、访问控制的功能



部署L2TP+IPSec服务器

```shell
yum -y install libreswan
yum install xl2tpd-1.3.8-2.el7.x86_64.rpm
```

创建IPSec加密配置文件

```shell
vim /etc/ipsec.d/myipsec.conf		#新建文件
conn IDC-PSK-NAT
	rightsubnet=vhost%priv			#允许的VPN虚拟网络
	also=IDC-PSK-noNAT			
conn IDC-PSK-noNAT
	authby=secret					#加密认证
	ike=3des-sha1;modp1024			#算法
	phase2alg=aes256-sha1;modp2048	#算法
  pfs=no
  auto=add
  keyingtries=3
  rekey=no
  ilkelifetime=8h
  keylife=3h
  type=transport
  left=201.1.2.10					#重要，服务器本机的外网ip
  leftprotoport=17/1701
  right=%any						#允许任何客户端连接
  rightprotoport=17/%any			
```

新建IPSec预定义共享密钥

```shell
cat /etc/ipsec.secrets 								#不要修改该文件
include /etc/ipsec.d/*.secrets 

vim /etc/ipsec.d/mypass.secrets 					#新建文件
201.1.2.10 		%any:     PSK 	  "randpass"		#randpass为密钥
```

启动IPSec服务

```shell
systemctl start ipsec
netstat -nutlp | grep pluto
```

修改xl2tp配置文件

```shell
vim /etc/xl2tpd/xl2tpd.conf
[global]
[Ins default]
ip range = 192.168.3.128-192.168.3.254			#分配给客户端的IP池
local ip = 201.1.2.10							#服务IP地址

vim /etc/ppp/options.xl2tpd						
require-mschap-v2								#添加一行
#crtscts										#注释或删除该行
#lock											#注释或删除该行

vim /etc/ppp/chap-secrets						#修改密码文件
jacob  *   123456   *
```

启动XL2TP服务

```shell
systemctl start xl2tpd
netstat -ntulp | grep xl2tpd
```

翻墙

```shell
echo "1" > /proc/sys/net/ipv4/ip_forward
firewall-cmd --set-default-zone=trusted
iptables -t nat -A POSTROUTING -s 192.168.3.0/24 -j SNAT --to-source 201.1.2.10
```

windows客户端 图形化配置

设置新的连接或网络 -> 连接到工作区 -> 使用我的Internet连接VPN -> 我将稍后设置Internet连接 

测试:连接到工作区



### systemd ###

linux系统的一组基本构建块

它提供了一个系统和服务管理器，作为PID1运行并启动系统的其余部分进程，控制systemd的主要命令是systemctl



systemctl命令

```shell 
systemctl 						  #列出所有启动的服务
systemctl status <服务名称> 	   	#查看服务状态
systemctl start <服务名称>			#启动服务状态
systemctl stop <服务名称>			#关闭服务状态
systemctl restart <服务名称>		#重启服务状态
systemctl enable <服务名称>			#设置开机自启
systemctl enable --now <服务名称>	#设置开机自启并启动
systemctl disable <服务名称>		#禁止开机自启
systemctl is-active <服务名称>		#查看是否激活
systemctl is-enabled <服务名称>		#查看是否开机自启
systemctl reboot 				  #重启计算机
systemctl poweroff 				   #关闭计算机
```



Unit文件

sysytemd管理服务时会读取对应的配置文件也就是unit文件

读取Unit文件的目录(优先级由高到低)

/etc/systemd/system	(设置了开机自启的Unit文件)

/usr/lib/systemd/system 	(所有已经安装软件的Unit文件)



Unit文件范例

```shell
cat /usr/lib/systemd/system/crond.service 
[Unit]
Description=Command Scheduler
After=auditd.service systemd-user-sessions.service time-sync.target
[Service]
EnvironmentFile=/etc/sysconfig/crond
ExecStart=/usr/sbin/crond -n $CRONDARGS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
[Install]
WantedBy=multi-user.target
```

Unit文件语法

| 语句            | 描述                                   |
| --------------- | -------------------------------------- |
| Description     | 描述信息                               |
| After           | 在哪个服务之后启动                     |
| Before          | 在哪个服务之前启动                     |
| type            | 服务类型，默认为simple                 |
| EnvironmentFile | 定义变量文件                           |
| ExecStart       | 执行systemctl start 需要启动的进程名称 |
| ExecStop        | 执行systemctl stop需要停止好的进程名称 |
| ExecReload      | 执行systemctl reload 需要执行的命令    |
| WantedBy        | 依赖当前服务的target                   |

```shell
#Nginx服务管理
[Unit]
Description=The nginx http server
After=network.target remote-fs.target nss-lookup.target
[Service]
Type=forking
ExecStart=/usr/local/nginx/sbin/nginx 
ExecReload=/usr/local/nginx/sbin/nginx -s reload
ExecStop=/bin/kill -s QUIT ${MAINPID}
[Install]
WantedBy=multi-user.target
```

如果在启动服务后，修改了/usr/lib/systemd/system目录下的Unit文件，则需要使用daemon-reload重新加载配置

systemctl daemon-reload



# Aotomation(自动化运维) #

## ansible基础 ##

首次发布于2012年，作者Michael DeHaan(也是cobbler的作者)，于2015年被redhat收购

Ansible基于Python开发：实现批量系统配置，批量程序部署， 批量运行命令等功能

特色：基于SSH架构，模块丰富，社区活跃，支持自定义模块，支持异构IT架构，部署简单，容易上手



实验环境部署：

192.168.4.253 (控制节点manager),192.168.4.11~15(被控制节点)



控制节点

配置SSH密钥

修改/etc/hosts、配置ssh密钥

```shell
vim /etc/hosts
ip 			被控制主机名

ssh-keygen -f /root/.ssh/id_rsa -N ''
for i in 主机名... ...
do 
	ssh-copy-id $i
done
```

部署软件(预先将ansible所需软件打成了tar包，压缩安装即可)

```shell
dnf -y install * 
```



被控制节点

被管理主机要开启ssh服务，并允许控制主机登录，被管理主机登录，被管理主机需要安装Python

修改主配置文件

ansible配置文件查找顺序

首先检测ANSIBLE_CONFIG变量定义的配置文件

其次检查当前目录下的./ansible.cfg文件

再次检车当前用户家目录下~/ansible.cfg文件

最后检查/etc/ansible/ansible.cfg文件

```shell
mkdir ~/ansible
cat ~/ansible/ansible.cfg
[defaults]
inventory =~/ansible/hosts 	#主机清单配置文件(文件名任意)
#forks =5					#ssh并发数量
#ask_pass =True				#使用密钥还是密码远程
#host_key_checking =False	#是否校验密钥
```

主机清单文件

```shell
cat ~/ansible/hosts
[test]					#定义主机组(组名任意)
node1					#定义组中的具体主机
[proxy]
node2
[webserver]
node3:4
[database]
node5
[cluster:children]		#嵌套组(children为关键字)
webserver
database
```



### ansible ad-hoc ###

ansible ad-hoc是一种通过命令行批量管理的方式

格式：ansible 主机集合 -m 模块名 -a "参数"

其他参数：-k 使用密码远程

```shell
cd ~/ansible
ansible all --list-hosts		#查看所有主机列表
ansible node1 -m ping 			#调用Ping模块
ansible node1,node2 -m ping
ansible webserver -m ping 
```

默认模块为command(模块就是脚本，多数模块都支持参数)

```shell
ansible-doc -l 				#列出所有模块
ansible-doc -l | grep yum 	#过滤模块
ansible-doc yum				#查看模块帮助
```



常用模块

#### shell模块 ####

command和shell模块的区别：

command模块的命令不启动shell，直接通过ssh执行命令

command不支持bash的特性，如管道和重定向等功能

所有需要调用shell的功能都无法使用

```shell 
ansible test -m command -a 'ps | wc -l'		#报错
ansible test -m command -a 'ls &'			#报错
```

shell模块会启动shell执行命令，不可以使用shell模块执行交互命令，如vim，top等

```shell
ansible test -m shell -a 'ps aux | wc -l' #进程数量
ansible -m shell -a 'who'				  #登录信息
```

shell模块支持判断(creates、removes)

creates 文件名：文件存在，不执行shell命令

removes 文件名：文件不存在，不执行shell命令

```shell
ansible test -m shell -a "ssh-keygen -f ~/.ssh/id_rsa -N '' creates=~/.ssh/id_rsa"
#如果有密钥文件id_rsa，则创建密钥(skip跳过)
ansible test -m shell -a "unzip xx.zip removes=/bin/unzip" 
#如果没有安装unzip包，则不执行解压命令(skip跳过)
```



#### script模块 ####

允许在本地写脚本，拷贝到被管理端并执行脚本

可以不是shell脚本(如python、perl脚本等)，可以没有-x

```shell
cat test.sh
#!/bin/bash
dnf -y install httpd
systemctl start httpd

ansible test -m script -a "./test.sh"
```



#### file模块 ####

可以创建文件、目录、链接；修改权限与属性等

-幂等性：任意次执行所产生的影响均与一次执行的影响相同

```shell
ansible test -m file -a "path=/tmp/file.txt state=toch" 		#新建文件
ansible test -m file -a "path=/tmp/mydir state=directory"		#新建目录
ansible test -m file -a "path=/tmp/file.txt owner=sshd group=adm mode=0777"	#修改文件或目录权限
ansible test -m file -a "path=/tmp/mydir state=absent" 			#删除目录
ansible test -m file -a "path=/tmp/file.txt state=absent"		#删除文件
ansible test -m file -a "src=/etc/hosts path=/tmp/hosts.txt state=link"  #给/etc/hosts文件创建一个链接文件/tmp/hosts.txt 
```



#### copy模块 ####

将文件拷贝到远程主机

-backup=yes如果目标主机有同名文件，则先备份

```shell
echo AAA > ~/a.txt 			#新建测试文件
ansible test -m copy -a "src=~/a.txt dest=/root/"
ansible test -m copy -a "content'hello the world\n' dest=/root/new.txt"	#通过content可以直接提供文件内容，\n表示回车
```



#### fetch模块 ####

与copy类似，但是作用相反：可以将其他主机的文件拷贝到本地

```shell
ansible test -m fetch -a "src=/etc/hostname dest=~/" #远程主机的hostname文件下载到本地家目录
```



#### lineinfile | replace模块 ####

在修改的单个文件的单行内容时可以使用lineinfile模块

```shell
ansible test -m lineinfile -a "path=/etc/issue line='hello world'"
#在/etc/issue文件中添加一行内容hello world，默认添加到最后
ansible test -m lineinfile -a "path=/etc/issue line='hello world'" 
#基于幂等原则，重复执行，不会创建多行内容
ansible test -m lineinfile -a "path=/etc/issue line='insert' insertafte='Kernel'"	
#将内容插入到Kernel行后面
ansible test -m lineinfile -a "path=/etc/issue regexp='hello' line='nihao'" 
#在/etc/issue文件中正则匹配包含hell的行，把整行内容替换为nihao，如果无法匹配到hello，则在文件最后一行添加nihao，如果多行内容包含hello，则仅替换最后一行
```

lineinfile会替换一整行，replace可以替换关键词

```shell
ansible test -m replace -a "path=/etc/issue.net regexp=Kernel replace=Ocean"
#将/etc/issue文件全文所有的Kernel替换为Ocean
```



#### user模块 ####

可以实现Linux系统账户管理

```shell 
ansible test -m user -a "name=tuser1 groups=root,daemon"
#修改用户tuser1的附加组
ansible test -m user -a "name=tuser1 state=absent" #删除账户tuser1
ansible test -m user -a "name=tuser2 state=absent remove=true" #删除账户tuser2用户的同时删除家目录、邮箱
```



#### yum_repository模块 ####

使用yum_repository可以创建或修改yum源配置文件

```shell 
ansible test -m yum_repository -a "name=myyum description=hello baseurl=ftp://192.168.4.254/centos gpgcheck=no"
#新建一个yum源配置文件/etc/yum.repos.d/myyum.repo,yum源文件名为myyum，该文件内容如下
[myyum]
baseurl = ftp://192.168.4.254/centos 
gpgcheck = 0
name = hello

ansible test -m yum_repository -a "name=muyum description=test baseurl=ftp://192.168.4.254/centos gpgcheck=yes gpgkey="
#修改yum源文件内容

ansible test -m yum_repository -a "name=myyum state=absent"
#删除yum源文件myyum
```



#### yum模块 ####

使用yum模块可以安装、卸载、升级软件包

-state：present(安装)、sbsent(卸载)、latest(升级)

```shell
ansible test -m yum -a "name=unzip state=present"

ansible test -m yum -a "name=unzip state=lastest"		#软件名可以是*,代表升级所有软件包

ansible test -m yum -a "name=unzip state=absent"
```



#### service模块 ####

为服务管理模块(启动、关闭、重启服务等)

state：started | stopped | restarted 

enabled：yes设置开机启动

```shell
ansible test -m yum -a "name=httpd"
ansible test -m yum -a "name=httpd state=started"
ansible test -m yum -a "name=httpd state=stopped"
ansible test -m yum -a "name=htppd state=restarted"
ansible test -m yum -a "name=httpd enabled=yes"
```



#### 逻辑卷相关模块 ####

lvg模块：创建、删除卷组(VG)，修改卷组大小

state:present(创建)|absent(删除)

```shell
ansible test -m yum -a "name=lvm2"	#安装lvm2软件包
ansible test -m lvg -a "vg=myvg pvs=/dev/vdb1"	#创建名称为myvg的卷组，该卷组由/dev/vdb1组成
ansible test -m lvg -a "vg=myvg pvs=/dev/vdb1,/dev/vdb2" #修改卷组大小
```

lvol模块：创建、删除逻辑卷(LV)，修改逻辑卷大小

state:present(创建)|absent(删除)

```shell
ansible test -m lvol -a "lv=mylv vg=myvg size=2G"	#使用myvg这个卷组创建一个名为mylv的逻辑卷
ansible test -m lvol -a "lv=mylv vg=myvg state=absent force=yes"	#删除逻辑卷 force强制
ansible test -m lvg -a "vg=myvg state=absent"	#删除卷组myvg
```



## sudo账户提权 ##

以超级管理员或其他人的身份执行命令

基本流程：管理源需要先授权(修改/etc/sudoers文件)，普通用户以sudo的形式执行命令，可以通过sudo -l查看授权情况



sudo语法：

修改/etc/sudoers的方法：visudo(带语法检查，默认没有颜色提示)、vim /etc/sudoers(不带语法检查，默认有颜色提示 )

授权格式：用户或组   		主机列表=(提权身份) 			[NOPASSWD]:命令列表

命令需要写绝对路径



例：

为所有被管理主机创建系统账户(用户名为alice，密码为123456)

```shell
ansible all -m user -a "name=alice password={{'123456' | password_hash('sha512')}}"
```

在所有被管理主机配置sudo，让alice可以执行任何命令(使用NOPASSWD开启无密码验证)

```shell
ansible all -m lineinfile -a "path=/etc/sudoers line='alice ALL=(ALL) NOPASSWD:ALL'
#验证
ssh alice 
sudo -l 
sudo systemctl restart chronyd
```



与ansible的运用

修改~/ansible/ansible.cfg

```shell
[defaults]
inventory = ~/ansible/hosts
remote_user = alice									#以什么用户远程被管理主机
#host_key_checking = False							#是否校验密钥						
[privilege_escalation]		
become = true										#是否需要切换用户
become_method = sudo 								#如何切换用户
become_user = root									#切换成什么用户
become_ask_pass = no 								#sudo是是否需要输入密码
```

使用alice远程被管理主机，需要提前配置ssh密钥

```shell
for i in 主机名
do 
		ssh-copy-id alice@$i
done
#测试效果
ansible all -m command -a "who"
```



## ansible主机清单列表 ##

inventory配置

修改主机清单文件，添加多个变量(多个变量空格分隔)

```shell
vim ~/ansible/hosts
[test]					
node1		ansible_ssh_port=220				#自定义远程ssh端口		
[proxy]
node2		ansible_ssh_user=alice				#自定义远程连接的账户名
[webserver]
node3:4		ansible_ssh_pass=密码				   #自定义远程连接的密码
[database]
node5		ansible_ssh_privare_key_file=密钥文件 #自定义远程连接的密钥
[cluster:children]		
webserver
database
```



## ansible playbook ##

ansible ad-hoc可以通过命令行形式远程管理其他主机，适合执行一些临时性简单任务

ansible playbook(剧本)

- 将经常需要执行的任务写入一个文件(剧本)
- 剧本中可以包含多个任务
- 剧本写后，我们随时根据剧本，执行相关的任务命令
- playbook剧本要求按照YAML格式编写
- 适合执行周期性经常执行的复杂任务



### YAML ###

是一个可读性高、用来表达数据序列的格式语言，以数据为中心，重点描述数据的关系和结构

#### YAML格式 ####

- "#"代表注释，一般第一行为三个横杠
- 键值对使用":"表示，数组使用"-"表示
- 一般缩进由两个或以上空格组成
- 相同层级的缩进必须对齐
- 全文不可以使用tab键
- 区分大小写、扩展名为yml或yaml
- 跨行数据需要使用>或者|(|会保留换行符)



YAML格式的键值对数据

- key和value直接使用":"分隔

- ":"后面必须由空格
- 缩进代表层级关系



YAML格式的数组数据

- 使用短横杠和空格表示，一行表示数据格式[值，值，值...]



例：

```yaml
-"诗人":
       - 唐代:
       		- "李白"
       		- "杜甫"
       - 宋代:
            - "苏轼"
            - "李清照"
```

```yaml
--- #跨行文本(计算机理解为一行)
自我介绍: >
       你好，
       我叫xxx,
       来自xxx
```

```yaml
--- #跨行文本(计算机理解为多行)
诗朗诵: |
     鹅鹅鹅，
     曲项向天歌。
     白毛浮绿水，
     红掌拨清波。      
```



### playbook语法格式 ###

playbook采用Yaml格式编写，文件中由一个或多个play组成

每个play中可以包含：hosts(主机)、tasks(任务)、variables(变量)、roles(角色)、handlers等元素组成

使用ansible-playbook命令运行playbook剧本



测试第一个playbook

```yaml
--- 
- hosts: all
  tasks: 
    - name: this is my first playbook
      ping:
```

ansible-playbook ~/ansible/test.yml



hosts由一个或多个组或主机组成，逗号分隔

tasks由一个或多个任务组成，多个任务按顺序执行

可以使用-f选项自定义并发量

```yaml
---
- hosts: test,webserver
  tasks: 
     - name: this is my first playbook
       ping:
     - name: Run a shell command
       shell: toch ~/shell.txt
```

ansible-playbook ~/ansible/test.yml -f 5



一个playbook中有多个play

```yaml
--- 
- hosts: test
  tasks: 
    - name: this is first play
      ping:
- hosts: webserver
  tasks: 
    - name: this is second play
      ping:
```



修改VIM配置：

- 使用2个空格自动替换tab键(tabstop=2、expandtab)
- 开启自动缩进对齐，缩进宽度为2个空格(shiftwidth=2)

```shell
vim ~/.vimrc
autocmd FileType yaml setlocal ai ts=2 sw=2 et
```



playbook应用案例：用户

编写playbook创建系统账户、账户属性、设置密码(花括号外面必须有双引号)

```yaml
---
- hosts: webserver
  tasks: 
    - name: add the user 'johnd'
      user: 
        name: johnd
        uid: 1040
        group: daemon
        password: "{{'123' | password_hash('sha512')}}"
```

```yaml
---
- hosts: webserver 
  tasks: 
    - name: add 'james' with a bash shell,set 'bin' and 'adm' to the user's groups
      user:
        name: james
        shell: /bin/bash
        groups: bin,adm
        password: "{{'123' | password_hash('sha512')}}"
```

```yaml
---
- hosts: webserver
  tasks: 
    - name: remove the user 'johnd'
      user: 
        name: johnd
        state: absent
```

使用vdb创建卷组和逻辑卷(手动添加虚拟磁盘)

```yaml
---
- hosts: test
  tasks: 
    - name: create a new primary partition with a size of 1Gib
      parted:
        device: /dev/vdb
        number: 1
        state: present
        part_end: 1GiB
     - name: create a new primary partition with a size of 2Gib
       parted: 
         device: /dev/vdb
         number: 2
         state: present
         part_end: 2GiB
     - name: create a volume group on top of /dev/vdb1
       lvg: 
         vg: my_vg
         pvs: /dev/vdb1
     - name: create a logical volume of 512m
       lvol:
         vg: my_vg
         lv: my_lv
         size: 512m
```

安装软件、升级软件、安装组包

```yaml
--- 
- hosts: webserver
  tasks: 
    - name: install a list of packages
      yum: 
        name: 
          - httpd
          - mariadb
          - mariadb-server
    - name: install the 'Development tools'package group
      yum: 
        name: "@Developmentools"
    - name: update software
      yum: 
        name: '*'
        state: lastest
```



## ansible进阶 ##

特殊模块

#### setup模块  ####

ansible_facts 用于采集被管理设备的系统信息，所有收集的信息都被保存在变量中

每次执行playbook默认第一个任务就是Gathering Facts，使用setup模块可以查看收集到的facts信息

```shell
ansible test -m setup
```



#### debug模块 ####

可以显示变量的值，可以辅助排错

```yaml
--- 
- hosts: 
  tasks: 
    - debug: 
        msg: "主机名是:{{ ansible_hostname }}"
    - debug:
        msg: "总内存大小:{{ ansible_memtotal_mb }}"
```



### 高级语法 ###

定义变量：ansible支持十几种定义变量的方式

根据优先级排序，一部分的变量：

Inventory变量

Host Facts变量

Register变量

Playbook变量

Playbook提示变量

变量文件

命令行变量



Inventory变量(在主机清单配置文件中定义变量)

```shell
vim ~/ansible/hosts
[test]
node1 iname="nb"
[webserver:vars]
iname="dachui"
```

```yaml
vim ~/ansible/inventory_var.yml
--- 
- hosts: webserver
  tasks:
    - name: create a user with var.
      user: 
        name: "{{iname}}"
```

Host Facts变量(可以直接调用ansible收集的系统信息)

```yaml
--- 
- hosts:
  tasks: 
    - name: Use facts info.
      copy: 
        content: "{{ansible_hostname}}:{{ansible_bios_version}}"
        dest: /tmp/facts.txt
```

register语句可以将某个命令的执行结果保存到变量中

```yaml
--- 
- hosts:
  tasks: 
    - name: save shell result to a variable.
      shell: hostname
      register: myvar
    - name: print the variable's value through debug
      debug: 
        msg: "{{myvar}}"
```

通过"." 还可以仅提取部分数据

```yaml
--- 
- hosts: 
  tasks: 
    - name: save shell result to a variable.
      shell: hostname
      register: myvar 
    - name: print the variable's value through debug 
      debug: 
        msg: "{{myvar.stdout}}"
```

playbook变量(使用vars关键词可以在playbook内定义变量)

```yaml
--- 
- hosts: test
  vars: 
    iname:heal
    ipass:'123456'
  tasks: 
    - name: use variables create user.
      user: 
        name: "{{iname}}"
        password: "{{ipass | password_hash('sha512')}}"
```

playbook提示变量(根据提示输入变量的值)

```yaml
---
- hosts: test
  vars_prompt: 
    - name: iname
      prompt: "请输入用户名"
      private: no 				#回显用户名
    - name: ipasswd
      prompt: "请输入密码"
      private: yes				#不显示密码
  tasks: 
    - name: create a user 
      user: 
        name: "{{iname}}"
        password: "{{ipasswd | password_hash('sha512')}}"
```

单独定义个变量文件，在playbook中用vars_files调用该文件

```yaml
vim ~/ansible/variables.yml
--- 
iname: cloud
ipass: '123456'

vim ~/ansible/file_var.yml
---
- hosts: test
  vars_files: variables.yml
  tasks: 
    - name: create user.
    	user: 
          name: "{{iname}}"
      	  password: "{{ipasswd | password_hash('sha512')}}"
```

执行ansible-playbook命令时使用-e参数定义数量

```yaml
--- 
- hosts: test
  tasks: 
    - name: create user.
      user: 
        name: "{{iname}}"
        password: "{{ipass | password_hash('sha512')}}"

ansible-playbook command_var.yml -e iname="beth" -e ipass="123456"
```



#### firewalld模块 ####

使用firewalld模块可以配置防火墙策略

```yaml
--- 
- hosts: test
  tasks: 
    - name: install firewalld.
      yum: 
        name: firewalld
        state: present
    - name: run firewalld
      service: 
        name: firewalld 
        state: started
        enabled: yes
    - name: set firewalld rule.
      firewalld: 
        port: 80/tcp					#在防火墙规则中添加一个放行tcp,80端口的规则
        permanent: yes					#permanent是设置永久规则
        immediate: yes					#immediate是让规则立即生效
        state: enabled					#state等于enabled是添加防火墙规则
```



#### template模块 ####

给webserver主机拷贝首页，每个主机内容不同.(使用环境自带变量)  

copy模块与template模块区别:template支持变量

```shell
mkdir ~/ansible/template
vim ~/ansible/template/index.html
Welcome to {{ansible_hostname}} on {{ansible_eth1.ipv4.address}}.
#模板文件中调用变量不需要双引号
```

```yaml
vim ~/ansible/tempalte.yml
--- 
- hosts: webserver
  tasks: 
    - name: use template copy index.html to webserver.
      template: 
        src: ~/ansible/template/index.html
        dest: /var/www/html/index.html
```

使用自定义变量

```yaml
vim ~/ansible/tempalte.yml
--- 
- hosts: webserver
  vars: 
    welcome: 'hello'
    iname: 'jack'
  tasks: 
    - name: use template copy a file to remote host.
      template: 
        src: ~/ansible/template/source.j2
        dest: /tmp/
```



#### error处理机制 ####

默认ansible在遇到error会立刻停止playbook

```yaml
--- 
- hosts: test
  ignore_errors: true 			#针对playbook全局忽略错误
  tasks: 
    - name: start a service that does not exist.
      service: 
        name: hehe				#没有这个服务
        state: started 
        ignore_errors: true 	#针对某一个任务忽略错误
    - name: touch a file.
      file: 
        path: /tmp/service.txt
        state: touch
```



#### handlers  ####

当某个任务需要依赖其他任务

- 可以通过handlers定义一组任务
- 仅当某个任务触发(notify)handlers时才会执行相应的任务
- 如果有多个notify触发执行handlers任务，也仅执行一次
- 仅当任务的执行状态为changed时handlers任务才执行
- handlers任务在所有其他任务都执行后才执行



```yaml
--- 
- hosts: test
  tasks: 
    - name: create directory 			#多次执行playbook该任务状态不再是changed
      file: 
        path: /tmp/parents/subdir/
        state: directory
      notify: touch file				#notify后面名称必须和handlers中的任务名称一致
  handlers: 
    - name: touch file 
      file: 
        path: /tmp/parents/subdir/new.txt
        state: touch
```



#### when条件判断 ####

when可以定义判断条件，条件为真时才执行某个任务

常见条件操作符如下：== 、!=、>、>=、<、<=

多个条件可以使用and或or分割

when表达式中调用变量不要使用{{}}

例：远程主机剩余内存不足700M则关闭NetworkManager服务

```yaml
---
- hosts: test
  tasks: 
    - name: check memory size.
      service: 
        name: NetworkManager
        state: stopped
      when: ansible_memfree_mb < 700
```

判断操作系统是RedHat8则创建测试文件

```yaml
--- 
- hosts: test
  tasks: 
    - name: touch a file 
      file: 
        path: /tmp/when.txt
        state: touch 
      when: >
        ansible_distribution == "RedHat"
              and 
        ansible_distribution_major_version == "8"
```



#### block任务块 ####

使用block可以将多个任务合并为一个组

```yaml
--- 
- hosts: test
  tasks: 
    - name: define a group of tasks.
      block:
        - name: install httpd
          yum: 
            name: httpd
            state: present
        - name: start httpd
          service: 
            name: httpd
            state: started
    when: ansible_distribution == "RedHat"
```

rescue定义block任务执行失败时要执行的其他任务

always定义无论block任务是否成功，都要执行的任务

```yaml
--- 
- hosts: test
  tasks: 
    - block: 
        - name: touch a file test1.txt
          file: 
            name: /tmp/test1.txt
            state: touch
      rescue: 
        - name: touch a file test2.txt
          file: 
            name: /tmp/test2.txt
            state: touch 
      always: 
        - name: touch a file test3.txt
          file: 
            name: /tmp/test3.txt
            state: touch
```



#### loop循环 ####

很多任务都在用相同的模块，使用loop循环避免重复

```yaml
---
- hosts: test
  tasks: 
    - name: mkdir multi directory.
      file: 
        path: /tmp/{{item}}					#item是关键字
        state: directory
      loop: 
        - School
        - Legend
        - Life
```

```yaml
--- 
- hosts: test
  tasks: 
    - name: create multi user.
      user: 
        name: "{{item.iname}}"
        password: "{{item.ipass|password_hash('sha512')}}"
      loop:
        - {iname:'term',ipass:'123456'}
        - {iname:'amy',ipass:'654321'}
```



### ansible vault ###

加密敏感数据

加密文件

ansible有时需要访问一些敏感数据，如密码、Key等

使用ansible-vault可以加密和解密数据、encrypt(加密)、decrypt(解密)、view(查看)

```shell
echo 123456 > data.txt						#新建测试文件
ansible-vault encrypt data.txt				#加密文件(设置密码)
cat data.txt								#查看不到内容(被加密了)
ansible-vault view data.txt					#查看加密文件(用刚刚设置的密码才能查看文件)
```

解密文件

```shell
ansible-vault decrypt data.txt				#输入密码解密
cat data.txt
```

修改密码

ansible-vault rekey可以修改加密的密码

```shell
ansible-vault encrypt data.txt				#加密文件(自定义密码)
ansible-vault rekey data.txt				#修改密码(旧密码，新密码，确认新密码)
```

密码文件

```shell 
echo 'i am secret data' > data.txt			#需要加密的敏感数据
echo 123456 > pass.txt						#加密的密码
ansible vault encrypt --vault-id=pass.txt data.txt 		#利用加密的密码加密文件
cat data.txt
ansible-vault decrypt --vault-id=pass.txt data.txt		#利用加密的密码解文件
cat data.txt
```

实践：

```shell
vim ~/ansible/variables.yml
ansible-vault encrypt variables.yml				#加密文件
vim ~/ansible/vault.yml 						#(需要调用variables.yml文件)
--- 	
- hosts: test
  vars_files: variables.yml
  tasks: 
    - name: include vault data,create user.
      user: 
        name: "{{iname}}"
        password: "{{ipass|password_hash('sha512')}}"
ansible-playbook --ask-vault-pass vault.yml 	#需要输入密码才可以调用被加密的yml文件
```



### ansible roles ###

ansible 1.2版本开始支持roles

roles是管理ansible文件的一种规范(目录结构)

roles会按照标准的规范，自动到特定的目录和文件中读取数据



#### roles规范的目录结构 ####

defaults/main.yml：定义变量的缺省值，优先级较低

files目录：存储静态文件的目录

handlers/main.yml：定义handlers

meta/main.yml：写作者、版本等描述信息

README.md：整个角色(role)的描述信息

tasks/main.yml：定义任务的地方

templates目录：存放动态数据文件的地方(模板文件)

vars/main.yml：定义变量，优先级高



#### roles应用 ####

创建role

ansible-galaxy命令可以创建、管理自己的roles

```shell
mkdir ~/ansible/roles
ansible-galaxy init ~/ansible/roles/issue 
#创建一个role，该role的目的是使用模板修改远程主机的/etc/issue
tree ~/ansible/roles/issue/
#查看目录结构
```



修改role

定义issue文件的模板文件

```jinja2
vim ~/ansible/roles/issue/templates/issue.j2
this is system {{ansible_hostname}}
today's date is:{{ansible_data_time.date}}
contact to {{admin}}
```

定义变量文件

```yaml
vim ~/ansible/roles/issue/vars/main.yml
---
#vars file for /root/ansible/roles/issue
admin:yoyo@tedu.cn
```

修改任务文件，任务文件中不需要tasks关键词

role的各个文件之间相互调用不需要写路径

```yaml
vim ~/ansible/roles/issue/tasks/main.yml
--- 
#tasks file for /root/ansible/roles/issue
- name: delever issue file
  template: 
    src: issue.j2
    dest: /etc/issue
```

在ansible.cfg配置roles_path=路径

```shell
vim ~/ansible/ansible.cfg
[defaults]
remote_user = root
inventory = ./inventory
roles_path = ./roles
[privilege_escalation]
become=True
become_method=sudo
become_user=root
become_ask_pass=False
```

编写playbook文件，通过roles关键词调用role

```yaml
vim ~/ansible/issue.yml
--- 
- hosts: test
  roles: 
    - issue
#   - role2 #支持加载多个role
```



ansible-galaxy

公共roles仓库(https://galaxy.ansible.com)

```shell
ansible-galaxy search 'httpd'			#联网搜索roles
ansible-galaxy info acandid.httpd 		#查看roles基本信息
ansible-galaxy install acandid.httpd -p ~/ansible/roles/ 	#下载roles到特定的目录
ansible-galaxy list -p roles/			#列出本地有哪些roles
```

下载roles的方法：使用ansible-galaxy install 或者编写requirements.yml文件

```yaml
vim ~/ansible/roles/reauirements.yml
#格式一：直接从ansible Galaxy官网下载
- src: acandid.httpd
#格式二：从某个git服务器下载
- src: http://gitlab.com/xxx/xxx.git
  scm: git
  version: 56e00a54
  name: nginx-acme
#格式三：下载tar包，支持http、https、file
- src: http://example.com/myrole.tar
  name: myrole
  
ansible-galaxy install -r roles/requirements.yml -p roles
```



## Cluster(集群) ##

### 集群及LVS ###

通过高速网络将很多服务集合起来一起，提供同一种服务，在客户端看来就像是只有一个服务器

可以在付出较低成本的情况下获得在性能、可靠性、灵活性方面的相对较高的收益

任务调度是集群系统中的核心技术

集群的目的：提高性能、降低成本、提高可靠性、增强可靠性

集群的分类：高性能计算集群HPC、负载均衡集群LB、高可用集群HA



### LVS ###

Linux虚拟服务器(LVS)是章文嵩在国防科技大学就读博士期间创建的

LVS可以实现高可用的、可伸缩的Web、mail、cache和media等网络服务

最终目标是利用Linux操作系统和LVS集群软件实现一个高可用、高性能、低成本的服务器应用集群



LVS集群组成：

前端：负载均衡层 -由一台或多台负载均衡调度器构成

中间：服务器群组层 -由一组实际运行应用服务的服务器组成

底端：数据共享存储层 -提供共享存储空间的存储区域



LVS术语

Direstory server：调度服务器

Real server：真实的服务器

VIP：虚拟IP地址(公布给用户访问的虚拟IP地址)

DIP：调度器连接后端节点服务器的IP地址

RIP：真实IP地址(集群节点上使用的IP地址)



LVS工作模式

VS/NAT 

- 通过网络地址转换实现的虚拟服务器
- 大并发访问时，调度器的性能成为瓶颈

VS/DR

- 直接使用路由技术实现虚拟服务器
- 节点服务器需要配置VIP，注意MAC地址广播

VS/TUN

- 通过隧道方式实现虚拟服务器



负载均衡调度算法

LVS目前实现了10种调度算法：

常用的4种：

轮询(Round Robin)

加权轮询(Weighted Round Robin)

最少连接(Least Connections)

加权最少连接(Weighted Least Connections)

其他：

源地址散列(Source Hashing)

目标地址散列(Destination Hashing)

基于局部性的最少链接

带复制的基于局部性的最少链接

最短的期望的延迟

最少队列调度



#### LVS-NAT集群 ####

安装ipvsadm

```shell 
yum -y install ipvsadm
```



ipvsadm用法

创建虚拟服务器

-A 添加虚拟服务器

-t 设置群集地址(VIP，Virtual ip)

-s 指定负载调度算法

添加、删除服务器节点

-a 添加真实服务器

-d 删除真实服务器

-r 指定真实服务器(Real server)的地址

-m 使用NAT模式；-g、-i 分别对应DR、TUN模式

-w 为节点服务器设置权重，默认为1

例：

```shell
ipvsadm -A -t 172.16.16.172:80 -s rr
ipvsadm -a -t 172.16.16.172:80 -r 192.168.7.21:80 -m 
ipvsadm -d -r 192.168.7.24:80 -t 172.16.16.172:80
```



查看IPVS

```shell
ipvsadm -Ln
```



应用案例：

client：192.168.4.10/24

director server：eth0 192.168.4.5/24 eth1 192.168.2.5/24 

real server：192.168.2.0/24



操作流程：

real server：配置web服务器

director server：安装并启用ipvsadm，创建虚拟服务器，向虚拟服务器中加入节点

client：连接虚拟服务器测试



部署LVS服务器

```shell
#打开ip_forward
vim /etc/sysctl.conf
net.ipv4.ip_forward = 1
sysctl -p
#启动ipvsadm
systemctl start ipvsadm 
systemctl enable ipvsadm
#创建虚拟服务器
ipvsadm -A -t 192.168.4.5:80 -s rr 
#向虚拟服务器中加入节点，并指定权重分别为1和2
ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.100 -m w1 
ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.200 -m w2
#查看配置
ipvsadm -Ln
#保存配置
ipvsadm-save > /etc/sysconfig/ipvsadm
#修改Director调度算法为WRR
ipvsadm -E -t 192.168.4.5:80 -s wrr
```

  

#### LVS-DR集群 ####

应用案例：

director：DIP 192.168.4.15/24 VIP 192.168.4.5/24 

real server：192.168.4.0/24



操作流程：

real server：配置web服务器，配置辅助IP地址、调整内核参数

director server：在上安装并启用ipvsadm、配置辅助ip地址、创建虚拟服务器、向虚拟服务器中加入节点



解决ARP广播的问题

因为负载均衡器和真实的服务器在同一网络并且VIP设置在集群中的每个节点上，此时集群内的真实服务器会尝试回答来自客户端的ARP广播，这就会产生问题，大家都说我是VIP

修改内核参数

arp_ignore(定义回复ARP广播的方式)：0(默认值)回应所有的本地地址ARP广播，本地地址可以配置在任意网路偶接口、1只回应配置在入站网卡接口上的任意IP地址的ARP广播

arp_announce：0(默认)使用配置在任意网卡接口上的本地IP地址，2对查询目标使用最适当的本地地址。在此模式下将忽略这个ip数据包的源地址并尝试选择与能与该地址通信的本地地址。首要选择所有的网络接口的子网中外出访问子网中包括该目标IP地址的本地地址。如果没有合适的地址被发现，将选择当前的发送网络接口或其他的有可能接受到该ARP回应的网络接口来进行发送



ARP防火墙

使用ARP防火墙也是可以禁止对VIP的ARP请求(备选方案非必须)

```shell
yum -y install arpttables_jf
arptables -A IN -d <virtual_ip> -j DROP
arptables -A OUT -s <virtual_ip> -j mangle > --mangle-ip-s <real_ip>
```



配置后端web服务器

```shell
#配置辅助vip地址(临时操作)
ifconfig lo:0 192.168.4.15 netmask 255.255.255.255 broadcast 192.168.4.15 up
#调整内核参数(临时操作)
echo 1 > /proc/sys/net/ipv4/conf/lo/arp_inore
echo 2 > /proc/sys/net/ipv4/conf/lo/arp_announce
echo 1 > /proc/sys/net/ipv4/conf/all/arp_inore
echo 2 > /proc/sys/net/ipv4/conf/all/arp_announce
```



配置LVS调度器

```shell
#配置辅助IP地址
ifconfig ech0:1 192.168.4.15 broadcast 192.168.4.15 netmask 255.255.255.255 up
#创建虚拟服务器
ipvsadm -A -t 192.168.10.100:80 -s wlc
#向虚拟服务器中加入节点
ipvsadm -a -t 192.168.4.15:80 -g -r 192.168.4.100 -w 1
ipvsadm -a -t 192.168.4.15:80 -g -r 192.168.4.200 -w 2
```



Client 利用ab进行大并发测试

在Director上查看连接数





### Keepalived热备 ###

运行原理

Keepalived检测每个服务器节点状态

服务器节点异常或工作出现故障，Keepalived将故障节点从集群系统中剔除

故障节点回复后，keepalived再将其加入到集群系统中，所有工作自动完成，无需人工干预



keepalived服务器

安装 yum -y install keepalived



配置文件解析/etc/keepalived/keepalived.conf

```shell
glo bal_defs{
 notification_email {					#设置报警收件人邮箱
   Mrsun176@163.com
 }
 notification_email_from ka@localhost	#设置发件人
 smtp_server 192.168.20.1 				#定义邮件服务器
 smtp_connect_timeout 30  
 route_id LVS_devel						#设置路由ID号
}
vrrp_instance VI_1{
 state MASTER 							#主服务器为master，辅助位backup
 interface eth0							#定义网络接口
 virtual_router_id 51					#主辅VRID号必须一致
 priority 100							#服务器优先级
 advert_int 1							
 authentication{
  auth_type pass
  auth_pass forlvs						#主辅服务器密码必须一致
 }
 virtual_ipaddress{192.168.4.80}
}
```



高可用web拓扑

使用Keepalived为主从设备提供VIP地址飘逸

keepalived  VIP：192.168.4.80/24 

web server  192.168.4.0/24



高可用web案例

```shell
#使用Keepalived为服务器提供VIP
vrrp_instance VI_1{
 state MASTER 					
 interface eth0			
 virtual_router_id 51
 priority 100
 advert_int 1
 authentication{
  auth_type pass
  auth_pass forlvs				
 }
 virtual_ipaddress{ 192.168.4.80 }
}
```



#### Keepalived + LVS ####

使用Keepalived高可用解决调度器单点失败问题

主、备调度器上配置LVS

主调度器异常时，Keepalived启用备用调度器调度器



keepalived配置说明

LVS相关信息通过Keepalived配置即可

主要配置文件

```shell
global_defs{
 notification_email {
  Mrsun176@163.com
 }
 notification_enamil_from ka@localhost
 smtp_server 192.168.20.1
 smtp_connect_timeout 30
 router_id LVS_devel
}
```



VRRP实例设置

```shell
vrrp_instance VI_1{
 state MASTER
 interface eth0
 virtual_router_id 51
 priority 100
 advert_int 1 
 authentication{
  auth_type pass
  auth_pass forlvs
 }
 virtual_ipaddress{192.168.4.15}
}
virtual_server 192.168.4.15 80
 delay_loop 6
 lb_algo rr 
 lb_kind DR
 persistence_timeout 50
 protocol TCP
 real_server 192.168.4.100 80{
  weight 3
  TCP_CHECK {
          connect_timeout 3
          nb_get_retry 3
          delay_before_retry 3
  }
 }
 real_server 192.168.4.200 80{同real100}
```



配置后端web服务器

```shell
#配置辅助vip地址(临时操作)
ifconfig lo:0 192.168.4.15 netmask 255.255.255.255 broadcast 192.168.4.15 up
#调整内核参数(临时操作)
echo 1 > /proc/sys/net/ipv4/conf/lo/arp_inore
echo 2 > /proc/sys/net/ipv4/conf/lo/arp_announce
echo 1 > /proc/sys/net/ipv4/conf/all/arp_inore
echo 2 > /proc/sys/net/ipv4/conf/all/arp_announce

#永久配置需要修改配置文件
 cd /etc/sysconfig/network-scripts/
 cp ifcfg-lo{,:0}
 vim ifcfg-lo:0
   	DEVICE=lo:0
    IPADDR=192.168.4.15
    NETMASK=255.255.255.255
    NETWORK=192.168.4.15
    BROADCAST=192.168.4.15
    ONBOOT=yes
    NAME=lo:0
    
vim /etc/sysctl.conf
#手动写入如下4行内容
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
#本机不要向外宣告自己的lo回环地址是192.168.4.15
```



### HAProxy ###

免费、快速并且可靠的一种解决方案

适用于那些负载特大的web热点，这些站点通常又需要会话保持或七层处理

提供高可用性、负载均衡以及基于TCP和HTTP应用的代理



衡量负责均衡器性能的因素

session rate 会话率

- 每秒钟产生的会话数

session concurrency 并发会话数

- 服务器处理会话的时间越长，并发会话数越多

data rate 数据速率

- 以MB/s或Mbps衡量



工作模式

mode http 

- 客户端请求被深度分析后再发往服务器

mode tcp

- 4层调度，不检查第七层信息

mode health

- 仅作健康状态检查，已经不建议使用



应用实例

HAProxy：192.168.4.5/24 

web server：192.168.2.0/24



HAProxy安装

```shell
yum -y install haproxy
```

配置文件

-default：为后续的其他部分设置缺省参数，缺省参数可以被后续部分重置

-listen：定义服务器集群

```shell
/etc/haproy/haproxy.cfg
global 
 log 127.0.0.1 local2
chroot /usr/local/haproxy
 pidfile /var/run/haproxy.pid 			#haproxy的pid存放路径
 maxconn 4000							#最大连接数，默认4000
 user haproxy
 group haproxy
 daemon 								#将进程放入daemon模式运行
defaults 
 mode httpd								#默认的模式mode{tcp|http|health}
 log global 							#采用全局定义的日志
 option dontlognull						#不记录健康检查的日志信息
 option httpclose						#每次请求完毕后主动关闭http通道
 option httplog							#日志类别http日志格式
 option redispatch						#serverid服务器挂掉后强制定向到其他健康服务器
 timeout client 300000					#客户端连接超时
 timeout server 300000					#服务器连接超时
 maxconn 60000							#最大连接数
 retries 3								#3次连接失败就认为服务不可用
listen stats 0.0.0.0:1080				#监听端口
 status refresh 30s						#统计页面自动刷新时间
 status uri /stats						#统计页面url
  status realm Haproxy Manager			#进入管理界面查看状态信息
 status auth admin:admin				#统计页面用户名和密码设置
 #stats hide-version					#隐藏统计页面上Haproxy的版本信息
listen websrv-rewrite 0.0.0.0:80
       balance roundrobin 
       server web1 192.168.20.101:80 check inter 2000 rise 2 fall 5
       server web2 192.168.20.102:80 check inter 2000 rise 2 fall 5
```

管理服务

启动服务 systemctl start haproxy

停止服务 systemctl stop haproxy

查看状态 systemclt status haproxy



集群调度软件对比

Nginx分析 

优点：

- 工作在7层，可以针对http做分流策略
- 1.9版本开始支持4层代理
- 正则表达式比Haproxy强大
- 安装、配置、测试简单，通过日志可以解决多数问题
- 并发量可以达到几万次
- Nginx还可以作为web服务器使用

缺点：

- 7层代理仅支持http、https、mail协议，应用面小
- 监控检查仅通过端口，无法使用url检查



LVS分析

优点：

- 负载能力强，工作在4层，对内存、CPU消耗低
- 配置性低，没有太多可配置性，减少人为错误
- 应用面广，几乎可以为所有应用提供负载均衡

缺点：

- 不支持正则表达式，不能实现动静分离
- 如果网站架构庞大，LVS-DR配置比较繁琐



HAProxy分析

优点：

- 支持session、cookie功能
- 可以用过url进行健康检查
- 效率、负载均衡速度，高于nginx，低于lvs
- HAProxy支持TCP，可以对MySQL进行负载均衡
- 调度算法丰富

缺点：

- 正则弱于Nginx
- 日志依赖于syslogd



### Ceph  ###

分布式存储

分布式是指一种独特的系统架构，它由一组网络进行通信、为了完成共同的任务而协调工作的计算机节点组成

分布式系统是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务

目的就是利用更多的机器，处理更多的数据

常用的分布式文件系统：Lustre、Hadoop、FastDFS、Ceph、GlusterFS



ceph是一个分布式文件系统

具有高扩展、高可用、高性能的特点

可以提供对象存储、块存储、文件系统存储，提供PB级别的存储空间(PB->TB->GB)

1024G*1024G=1048576G



ceph组件

OSDs：存储设备

Monitors：集群监控组件

RadosGateway(RGW)：对象存储网关

MDSs：存放文件系统的元数据(对象存储和块存储不需要该组件)

Client：ceph客户端



#### 部署ceph存储集群 ####

实验环境：1台客户端虚拟机(192.168.4.10)，3台存储集群虚拟机(192.168.4.11,192.168.4.12,192.168.4.13)

配置ceph的yum源

```shell
yum -y install vsftpd
mkdir /var/ftp/ceph
mount -o loop ceph10.iso /var/ftp/ceph
systemctl restart vsftpd

#其他虚拟机调用yum源
vim /etc/yum.repos.d/ceph.repo
[mon]
name=mon
baseurl=ftp://192.168.4.10/ceph/MON
gpgcheck=0
[osd]
name=osd
baseurl=ftp://192.168.4.10/ceph/OSD
gpgcheck=0
[tools]
name=tools
baseurl=ftp://192.168.4.10/ceph/Tools
gpgcheck=0
```

配置SSH无密码连接

修改主机名/etc/hosts解析的域名必须与本机主机名一致

```shell
vim /etc/hosts
192.168.4.10 client
192.168.4.11 node1
192.168.4.12 node2
192.168.4.13 node

for i in 10 11 12 13
do 
 scp /etc/hosts 192.168.4.$i:/etc/
done

ssh-keygen -f /root/.ssh/id_rsa -N ''
for i in 10 11 12 13
do 
 ssh-copy-id 192.168.4.$i
done
```

NTP时间同步

```shell
#真实主机是NTP服务器，其他所有主机与其同步时间
vim /etc/chrony.conf
server 192.168.4.254 iburst
systemctl restart chronyd
```

准备存储磁盘

物理机上位每个虚拟机创建2个磁盘(命令行操作)，或者在图形操作

```shell
cd /var/lib/libvirt/images
qemu-img create -f qcow2 node1-vdo.vol 10G
```



部署Ceph集群

使用node1作为部署主机

```shell
yum -y install ceph-deploy
```

创建目录：为部署工具创建目录，存放密钥与配置文件

```shell
mkdir ceph-cluster
cd ceph-cluster
```

创建ceph集群

```shell
#创建ceph集群配置(所有节点为mon)
ceph-deploy new node1 node2 node3 
#给所有节点安装ceph软件包
for i in node1 node2 node3 
do 
  ssh $i "yum -y install ceph-mon ceph-osd ceph-mds ceph-radosgw"
done 
#初始化所有节点的mon服务(主机名解析必须对)
ceph-deploy mon create-initial

#初始化monitor常见错误
#如果提示如下错误信息
[node1][ERROR]admin_socket:exception getting command descriptions:
[Error 2]No such file or directory
#解决方案(在node1操作)
vim ceph.conf #文件最后追加以下内容
public_network = 192.168.4.0/24
#修改后重新推送配置文件
ceph-deploy --overwrite-conf config push node1 node2 node3

```

创建OSD

```shell
#初始化清空磁盘数据(仅node1操作即可)
ceph-deploy disk zap node1:vdb node1:vdc
ceph-deploy disk zap node2:vdb node2:vdc
ceph-deploy disk zap node3:vdb node3:vdc

#创建OSD存储空间(仅node1操作即可)
ceph-deploy osd create node1:vdb node1:vdc
ceph-deploy osd create node2:vdb node2:vdc
ceph-deploy osd create node3:vdb node3:vdc

#验证
ceph -s 

#可能出现的错误 osd create 创建osd存储空间，如提示run 'gatherkeys'
ceph-deploy gatherkeys node1 node2 node3

#查看状态,如果失败,在所有节点，或仅在失败节点重启服务
systemctl restart ceph\*/service ceph\*.target

#警告：将所有主机的时间都使用NTP时间同步
health:HEALTH_WARN
clock skew detected on node2,node3...
clock skew(时间不同步) 
```



Ceph块存储

单机块设备：光盘，磁盘

分布式块存储：Ceph、Cinder



ceph块设备也叫做RADOS块设备RBD

RBD提供企业功能、如快照、COW克隆等

RBD还支持内存缓存，从而能够大大提高性能

Linux内核可用直接访问Ceph块存储

KVM可用借助于librbd访问



#### 部署块存储集群 ####

```shell
#查看存储池(默认有一个rbd池)
ceph osd lspools 
#创建镜像、查看镜像
rbd create demo-image --imgae-feature layering --size 10G
rbd create rbd/image --image-feature layering --size 10G
rbd list 
rbd info demo-image
#缩小容量
rbd resize --size 7G image --allow-shrink
rbd info image
#扩容容量
rbd resize --size 15G image
rbd info image
```

客户端通过KRBD访问

```shell
#客户端需要安装ceph-common软件包
yum -y install ceph-common
#拷贝配置文件(否则不知道集群在哪)
scp 192.168.4.11:/etc/ceph/ceph.conf /etc/ceph/
#拷贝连接密钥(否则无法连接)
scp 192.168.4.11:/etc/ceph.client.admin.keyring /etc/ceph/
#映射镜像到本地磁盘
rbd map image 
lsblk 
rbd showmapped

#客户端格式化、挂载分区
mkfs.xfs /dev/rbd0
mount /dev/rbd0 /mnt/
echo "test" > /mnt/test.txt
#客户端撤销磁盘映射
umount /mnt
#取消RBD磁盘映射
rbd showmapped
rbd unmap /dev/rbd/rbd/image
#删除镜像
rbd list
rbd rm image 
```



块存储应用案例

```shell
#查看镜像快照
rbd snap ls image
#创建镜像快照	快照使用COW技术，对大数据快照速度会很快
rbd snap create image --snap image-snap1
rbd snap ls image 

#使用快照回复数据
#删除客户端写入的测试文件
rm -rf /mnt/test.txt
#还原快照
rbd snap rollback image --snap image-snap1
#客户端重新挂载分区
umount /mnt
mount /dev/rbd0/mnt/
ls /mnt

#快照克隆：如果想从快照恢复出来一个新的镜像，则可以使用克隆。注意，克隆前，需要对快照进行<保护>操作，被保护的快照无法删除，取消保护(unprotect)
rbd snap protect image --snap image-snap1
rbd snap rm image --snap image-snap1 #会失败
rbd clone image --snap image-snap1 image-clone --image-feature layering
#使用image的快照image-snap1克隆一个新的image-clone镜像

#查看克隆镜像与父镜像快照的关系
rbd info image-clone
#克隆镜像很多数据都来自于快照链，如果希望克隆镜像可以独立工作，就需要将父快照中的数据，全部拷贝一份，但比较耗时
rbd flatten image-clone 
rbd info image-clone

#删除快照
rbd snap rm image --snap image-snap
```



#### 分布式文件系统 ####

cephfs：分布式文件系统指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连

cephfs使用ceph集群提供与posix兼容的文件系统

允许linux直接将ceph存储mount到本地



实验环境：1台客户端虚拟机(192.168.4.10) 部署节点Mon，OSD ，3台存储集群虚拟机(192.168.4.11 部署节点Mon，OSD,192.168.4.12 部署节点Mon，OSD,192.168.4.13 部署节点Mon，OSD，MDs)



元数据服务器

元数据：任何文件系统中的数据分为数据和元数据，数据是指普通文件中的实际数据，而元数据指用来描述一个文件的特征的系统数据，比如：访问权限、文件拥有者以及文件数据块的分布信息(inode..)等

cephfs必须有MDSs节点



部署元数据服务器

```shell
#登录node3,安装ceph-mds软件包
yum -y install ceph-mds
#登录node1部署节点操作
cd /root/ceph-cluster
ceph-deploy mds create node3
#给node3拷贝配置文件，启动mds服务
```

创建存储池

文件系统需要至少2个池：一个池用于存储数据，一个池用于存储元数据

```shell
ceph osd pool create cephfs_data 64	#创建存储池，对应64个PG
ceph osd pool create cephfs_metadata 64 #创建存储池，对应64个PG
```

创建ceph文件系统

使用前面创建的池，创建文件系统

```shell
ceph mds stat #查看mds状态
ceph fs new myfs1 cephfs_metadata cephfs_data	#注意，现写metadata池，再写data池,默认只能创建一个文件系统，多余的会报错
ceph fs ls
```

客户端挂载(linux内核支持ceph文件系统，不需要装软件)

```shell
mount -t ceph 192.168.4.11:6789:/ /mnt/ -o name=admin,secret=
#文件系统类型为ceph，192.168.4.11为mon节点的ip(不是osd节点),admin是用户，secret是密钥，密钥可以在/etc/ceph/ceph.client.admin.keyring中找到
```



#### ceph对象存储 ####

对象存储，也就是键值存储，通其接口指令，也就是简单的GET、PUT、DEL和其他扩展，向存储服务上传下载数据

对象存储中所有数据都被认为是一个对象，所以，任何数据都可以存入对象存储服务器，如图片、视频、音频等

RGW全称是Rados Gateway

RGW是ceph对象存储网关，用于向客户端应用呈现存储界面，提供RESTful API访问接口



实验环境：一台虚拟机作为rgw服务器(192.168.4.13 主机名node4 配置yum源:包括rhel、ceph的源 与client主机同步时间 node1允许无密码远程node4)



部署RGW软件包

```shell
#用户需要通过RGW访问存储集群
yum -y install ceph-radosgw
```

新建网关实例

```shell
#启动一个rgw服务
ceph-deploy rgw create node4
#登录node4验证服务是否启动
ps aux | grep radosgw 
systemctl status ceph-radosgw@\*
```

修改服务端口

```shell
#登录node4，RGW默认服务端口为7480，修改为8000或80更方便客户端记忆和使用
vim /etc/ceph/ceph.conf
[client.rgw.node4]
host = node4
rgw_frontends = "civetweb port=8000"

#civetweb是RGW内置的一个web服务
```

 

## Security(监控) ##

### Zabbix ###

监控的目的

报告系统运行状况

- 每一部分必须同时监控
- 内容包括吞吐量(网络、设备、端口、虚电路或其他设施，单位时间内成功地传送数据的数量（以比特、字节、分组等测量))、反应时间、使用率等

提前发现问题

- 进行服务器性能调整前，知道调整什么
- 找出系统的瓶颈在什么地方



监控的资源类别

公开数据

- web、ftp、ssh、数据库等应用服务
- tcp或udp端口

私有数据

- cpu、内存、磁盘、网卡流量等使用信息
- 用户、进程等运行信息



监控软件

系统监控命令

ps、uptime、free、ifconfig、swapon -s 、df -h、netstat或ss、ping、traceroute、iostat



自动化监控系统

cacti 基于snmp协议的监控软件，强大的绘图能力

ngios 基于agent监控，强大的状态检查与报警机制，插件极多，自己写监控脚本嵌入到nagios非常方便

zabbix 基于多种监控机制，支持分布式监控



zabbix是一个高度集成的监控解决方案，可以实现企业级的开源分布式监控

zabbix通过c/s模式采集监控数据，通过b/s模式实现web管理



监控服务器(需要使用web页面操作，因此需要先部署LNMP)

- 监控服务器可以通过SNMP或Agent采集数据
- 数据可以写入MySQL、Oracle等数据库中
- 服务器使用LNMP实现web前端的管理

被监控主机

- 被监控主机需要安装agent
- 常见的网络设备一本支持SNMP



实验环境：

监控服务器

设置主机名(zabbix server) 、设置IP地址(192.168.2.5) 、关闭防火墙、SELinux

监控客户端

主机web1(192.168.2.100)

主机web2(192.168.2.200)

关闭防火墙、SELinux



部署LNMP

```shell
yum -y install gcc pcre-devel zlib-devel openssl-devel 
tar -xf nginx-1.12.2.tar.gz
cd nginx-1.12.2
./configure --with-http_ssl_module
make && make install 
yum -y install php php-fpm php-mysql mariadb mariadb-devel mariadb-server
vim /usr/local/nginx/conf/nginx.conf
http{
... ...
	 		  fastcgi_buffers 8 16K;		#缓存php生成的页面内容，8哥16K
	 		  fastcgi_buffer_size 32k;		#缓存php生成的头部信息
	 		  fastcgi_connect_timeout 300;	#连接php的超时时间
	 		  fastcgi_send_timeout 300;		#发送请求的超时时间
	 		  fastcgi_read_timeout 300;		#读取请求的超时时间
	location ~\.php$ {
 			  root html;
 			  fastcgi_pass 127.0.0.1:9000;
 			  fastcgi_index index.php;
 			  include fastcgi.conf;
 			}
}
systemctl start mariadb
systemctl start php-fpm
/usr/local/nginx/sbin/nginx 
#测试
vim /usr/local/nginx/html/test.php
<?php
$i=33;
echo $i;
?>

#修改防火墙和selinux
firewall-cmd --set-default-zone=trusted
setenforce 0
sed -i '/SELINUX/s/enforcing/permissive/'  /etc/selinux/config
```



部署zabbix

```shell
#安装软件
yum -y install net-snmp-devel curl-devel libevent-devel autoconf 
tar -xf zabbix-3.4.4.tar.gz
cd zabbix-3.4.4
./configure --enable-server \				#安装部署zabbix服务器端软件
--enable-proxy \							#安装部署zabbix代理相关软件
--enable-agent \							#安装部署zabbix被监控端软件
--with-mysql=/usr/bin/mysql_config \		#指定mysql_config路径
--with-net-snmp \							#允许zabbix通过snmp协议监控其他设备(如交换机、路由器)
--with-libcurl								#安装相关curl库文件，这样zabbix就可以勇敢curl连接http等服务，测试被监控主机服务的状态
make && make install 
```



创建并初始化数据库

```shell
mysql 
create database zabbix character set utf8;
grant all on zabbix.* to zabbix@'localhost' identified by 'zabbix';

cd lnmp_soft/zabbix-3.4.4/database/mysql/
mysql -uzabbix -pzabbix zabbix < schema.sql
mysql -uzabbix -pzabbix zabbix < images.sql 
mysql -uzabbix -pzabbix zabbix < data.sql
```



修改zabbix_server配置并启动监控服务

```shell
vim /usr/local/etc/zabbix_server.conf
DBHost=localhost					#85行定义哪台主机位数据库主机，localhost为本机
DBName=zabbix						#95行，设置数据库名称
DBUser=zabbix 						#111行，设置数据库用户
DBPassword=zabbix					#119行，设置数据库密码
LogFile=/tmp/zabbix_server.log		#38行，日志的位置

useradd -s /sbin/nologin zabbix
zabbix_server 						#启动服务
echo zabbix_server >> /etc/rc.local	#设置开机自启动
ss -ntulp | grep zabbix_server		#确认连接端口10051

#如果服务启动失败，一定要使用killall zabbix_server关闭后，再启动(killall命令来自于psmisc软化包)
#附加通过sevice文件管理zabbix服务
cd /usr/lib/systemd/system/
vim zabbix_server.service 
[Unit]
Description=zabbix server
After=network.target remote-fs.target nss-lookup.target
[Service]
Type=forking
PIDFile=/tmp/zabbix_server.pid
ExecStart=/usr/local/sbin/zabbix_server
ExecStop=/bin/kill $MAINPID
[Install]
WantedBy=multi-user.target
```



修改zabbix_agent配置并启动zabbix_agent服务

```shell
vim /usr/local/etc/zabbix_agentd.conf
Server=127.0.0.1,192.168.2.5				#93行，允许哪些主机监控本机
ServerActive=127.0.0.1,192.168.2.5			#134行，允许哪些主机通过主动模式监控本机
Hostname=zabbix_server						#145行，设置本机主机名(名称可任意)
LogFile=/tmp/zabbix_agentd.log				#设置日志文件
UnsafeUserParameters=1						#280行，是否允许自定义监控传参

zabbix_agent								#启动监控agent
echo zabbix_agent >> /etc/rc.local			#设置开机自启
ss -nutlp | grep zabbix_agentd				#确认连接端口10050
#如果启动失败和上面zabbix_server一样的步骤
#附加通过service文件管理zabbix服务
vim /usr/lib/systemd/system/zabbix_agentd.service
[Unit]
Description=zabbix agent
After=network.target remote-fs.target nss-lookup.target
[Service]
Type=forking
PIDFile=/tmp/zabbix_agentd.pid
ExecStart=/usr/local/sbin/zabbix_agentd
ExecStop=/bin/kill $MAINPID
[Install]
WantedBy=multi-user.target
```



上线zabbix的web页面

```shell
cd lnmp_soft/zabbix_3.4.4/frontends/php/
cp -r * /usr/local/nginx/html/
chown -R apache.apache /usr/local/nginx/html
```



浏览器访问zabbix_server服务器的web页面

```shell
firefox http://192.168.2.5/index.php

#根据错误提示,修改php配置文件,满足zabbix_server的web环境要求
yum -y install php-gd php-xml php-bcmath php-mbstring
vim /etc/php.ini
date.timezone = Asia/Shanghai					#878行，设置时区
max_execution_time = 300						#384行，最大执行时间，秒
post_max_size = 32M								#672行，POST数据最大容量
max_input_time = 300							#394行，服务器接收数据的时间限制
memory_limit = 128M								#405行，内存容量限制
```

图形化创建即可



配置被监控主机zabbix agent

```shell
#这里在2.100操作,2.200操作一致
useradd -s /sbin/nologin zabbix 
yum -y install gcc pcre-devel autoconf
tar -xf zabbix-3.4.4.tar.gz
cd zabbix-3.4.4/
./configure --enable-agent
make && make install 
vim /usr/local/etc/zabbix_agentd.conf
Server=127.0.0.1,192.168.2.5					#93行，谁可以监控本机(被动监控模式)
ServerActive=127.0.0.1,192.168.2.5				#134行，谁可以监控本机(主动监控模式)
Hostname=web1									#145行，被监控主机的主机名
EnableRemoteCommands=1							#69行，监控异常后，是否允许服务器远程过来执行命令，如重启某个服务
UnsafeUserParameters=1							#280行，是否允许自定义key传参

zabbix_agentd
echo zabbix_agentd >> /etc/rc.local
chmod +x /etc/rc.local
firewall-cmd --set-default-zone=trusted
sed -i '/SELINUX/s/enforcing/permissive/' /etc/selinux/config
setenforce 0
```



自定义监控

自定义key

```shell
#被监控端修改agent配置文件
vim /usr/local/etc/zabbix_agentd.conf
UnsafeUserParameters=1							#280行，是否允许自定义key传参
Include=/usr/local/etc/zabbix_agentd.conf.d/	#264行,加载配置文件目录
#创建自定义key
cd /usr/local/etc/zabbix_agentd.conf.d/
vim count.line.passwd
UserParameter=count.line.passwd,sed -n '$='/etc/passwd
#自定义key语法格式 UserParameter=自定义key名称,命令

#重启agentd
killall zabbix_agentd
zabbix_agentd

#测试自定义key是否生效
zabbix_get -s 127.0.0.1 -k count.line.passwd
#如提示check access restrictions in zabbix agent configuration 则需要检查配置文件Server行

```



zabbix更高阶操作，查看图片

### Linux基本防护 ###

设置账号有效期，使用chage命令



账号的锁定/解锁，使用passwd命令



强制定期修改密码

配置文件/etc/login.defs (对新建的用户有效)

主要控制属性

PASS_MAX_DAYS

PASS_MIN_DAYS

PASS_WARN_AGE



伪装登录提示

配置/etc/issue、/etc/issue.net

分别适用于本地、远程登录，默认会提示内核、系统等版本信息



#### 文件系统安全   ####

程序和服务控制：禁用非必要的系统服务，使用systemctl、chkconfig工具

可选服务列表：

| cups.serice            | 打印服务                      |
| ---------------------- | ----------------------------- |
| postfix.service        | 邮件服务                      |
| NetworkManager.service | 网络管理服务(network可以替代) |
| firewalld              | 防火墙(iptables可以替代)      |
| atd.service            | 一次性计划任务(crond可以替代) |
| bluetooth.service      | 蓝牙服务                      |
| autofs.service         | 自动挂载                      |
| pcscd.service          | 智能卡设备资源管理器          |



#### 用户切换与提权 ####

su 换人(substitute user)

快速切换为指定的其他用户，普通用户执行时，需验证目标用户的口令

root执行时，无需验证口令

格式：

su [-] [目标用户]

su [-] -c "命令" [目标用户]



sudo提示执行权限

sudo (super or another do)，超级执行

- 管理员预先为用户设置执行许可
- 被授权的用户有权执行授权的命令，验证自己的口令

执行提权命令：

sudo 提权命令

查看提权命令：

sudo -l



配置sudo提权

修改方法：visudo , vim /etc/sudoers

授权记录格式：

用户  				主机列表=命令列表

root(可以是组名 %组名) ALL主机名=(ALL)目标身份，省略时表示root 



命令列表要写绝对路径，禁用的命令需要在前面加"!"

无需验证可执行所有命令  	NOPASSWD:ALL

修改全局配置，启用日志 Defaults logfile="/var/log/sudo"

sudo别名设置：提高可重用性，易读性，简化配置，使记录更有条理

```shell
visudo										#别名名称必须大写
User_Alias OPERATORS=jerry,tom,abc
Host_Alias MAILSERVERS=mail,smtp,pop,svr7
Cmnd_Alias SOFTMGR=/bin/rpm,/usr/bin/yum
OPERATORS MAILSERVERS=SOFTMGR
```



#### SSH基本防护 ####

常见防护措施：用户限制、黑白名单，更改验证方式(密码--密钥对)，防火墙...



sshd基本安全配置

配置文件/etc/ssh/sshd_config

Port 端口号						#改用非标准端口

PermitRootLogin	no 	#禁止root登录

UseDNS no					   #不解析客户机地址

LoginGraceTime 1m	   #登录限时

MaxAuthTries 3			   #每连接最多认证次数



黑白名单配置

DenyUsers USER1 USER2...

AllowUsers USER1@HOST USER2 ...

DenyGroups GROUP1 GROUP2 ...

AllowGroups GROUP1 GROU2 ...



例：仅允许一部分用户(从指定地点)登入，其他任何用户均禁止登入

```shell
vim /etc/sshd_config
AllowUsers abc@192.168.1.*,192.168.4.110
AllowUsers dbc tom jerry
systemctl restart sshd
```



ssh密钥对验证

口令验证：检查登录用户的口令是否一致

密钥验证：检查客户端私钥与服务器上的公有是否匹配(.ssh/authorized_keys 公钥库)



创建密钥对

ssh-keygen 

可以手动指定加密算法(-t rsa 或 -t dsa)

若不指定，默认采用RSA加密

可以指定私钥文件地址 -f 

设置密码 -N



部署ssh公钥

1.ssh-copy-id 自动部署(要求ssh口令认证可用)

2.通过ftp等方式上传，手动添加



测试ssh登录，需要验证私钥口令(如果没有则免密登录)



#### SELinux安全防护 ####

强化linux安全的扩展模块，美国国家安全局主导开发

SELinux运作机制：集成到linux内核(2.6及以上)，操作系统提高可定制的策略、管理工具



redhat的SELinux策略集

SELINUXTYPE=targeted

仅保护最常见/关键的网络服务，其他不限制

主要软件包：selinux-policy、selinux-policy-targeted、libselinux-utils、libselinux-utils、coreutils、policycoreutils

sestatus 		#查看selinux信息



SELinux模式控制

方法一，修改kernel启动参数

添加 selinux=0 以禁用

添加 enforcing=0 设置SELinux为允许模式

方法二，修改文件/etc/selinux/config

设置SELINUX=disabled以禁用

设置SELINUX=permissive宽松/允许模式

设置SELINUX=enforcing 强制模式



临时调整，setenforce命令		(非disabled状态下可用)

设为1，对应强制模式

设为0，对应宽松模式		

getenforce		查看当前状态



SELinux策略设置

查看安全上下文值(为文件/目录/设备标记访问控制属性)

```shell
ls -Z /bin/ls /etc/fstab
ls -dZ /var/www/html
```



修改安全上下文值

使用chcon工具

-t 指定访问类型

-R 递归修改

一般操作规律：移动的文件，原有的上下文属性不变。复制的文件，自动继承目标位置的上下文



重置安全上下文

使用restorecon工具

恢复为所在位置的默认上下文属性

-R 递归修改

/.autorelabel文件 下次重启后全部重置



调整SELinux布尔值

使用getsebool查看

-a 可列出所有布尔值

使用setsebool设置

-P 永久更改，重启后仍然有效



### 加密与解密 ###

对称加密：加密/解密用同一个密钥

非对称加密：加密/解密用不同的密钥(公钥，私钥)

保护信息的完整性：信息摘要(基于输入的信息生成长度较短、位数固定的散列值)



常见的加密算法

对称加密：DES、AES

非对称加密：RSA、DSA

hash散列技术，用于信息摘要：MD5、SHA



MD5完整性检验

```shell
md5sum supersos.iso
iptables -nL | md5sum 
```



GPG加密工具

流行的数据加密、数字签名工具软件



GPG对称加/解密

加密操作：--symmetric 或 -c

解密操作：--decrypt 或 -d



基本过程：

用户A把自己的公钥传给用户B

用户B使用公钥加密数据，将加密后的数据传给用户A

用户A使用自己的私钥解密数据

对应操作：

--gen-key 创建密钥对

--export、--armor或-a 导出公钥

--import 导入公钥

--encrypt 或 -e 加密操作

--recipient 或 -r 指定目标用户

--decrypt 或 -d 解密

应用：

```shell
gpg --gen-key 					#(设置用户信息，私钥口令)	用户a
gpg --list-keys					#查看 用户a
gpg -a --export userb > /tmp/userb.pub #导出公钥 用户a
gpg --import /tmp/userb.pub 	#导入公钥 用户b
gpg -e -r userb clear.txt		#加密 用户b
gpg -d /clear.txt > dclear.txt	#解密 用户a
```



GPG软件签名与验证

软件官方以私钥对软件包执行数字签名，用户下载软件包、软件官方的公钥，以官方公钥验证软件包签名，确保数据来源正确

为软件包建立签名文件

分离式签名：--detach-sign 或 -b

验证软件包签名：--verify

```shell
gpg -b /tmp/denyhostt-2.6.tar.gz		#建立签名文件	用户a
gpg --import /tmp/userb.pub				#导入官方公钥 用户b
gpg --verify /tmp/denyhostt-2.6.tar.gz.sig	#验证软化包
```



### AIDE入侵检测系统 ###

安装软件包使用yum -y install aide

修改配置文件/etc/aide.conf

```shell
vim /etc/aide.conf
@@define DBDIR /var/lib/aide				#数据库目录
@@define LOGDIR /var/log/aide				#日志目录
database_out=file::@@{DBDIR}/aide.db.new.gz	#数据库文件名
#p: permissions								#希望检查的项目
#i: inode:
#n: number of links
#u: user
#g: group
#s: size
#md5: md5 checksum
#sha1: sha1 checksum
#sha256: sha256 checksum
FIPSR = p+i+n+u+g+s+m+c+acl+selinux+xattrs+sha256
/boot NORMAL							 	#对那些目录进行什么校验
/bin NORMAL
/sbin NORMAL
/lib NORAML
/lib64 NORMAL
/opt NORMAL
/usr NORMAL
/root NORMAL
!/usr/src 									#使用[!]，设置不校验的目录
!/usr/tmp	
```



初始化检查

在没有攻击入侵前，根据配置文件，对数据进行校验操作

```shell
aide --init
```

备份数据库

在被入侵前，将校验的数据库文件备份到安全的地方



入侵检查

执行入侵检查

```shell
#将之前备份的校验数据库文件还原
cp /media/ /var/lib/aide/aide.db.gz
#根据数据库进行入侵检测
aide --check
```



### 扫描与抓包 ###

以获取一些公开/非公开信息为目的

- 检测潜在的风险
- 查找可攻击目标
- 收集设备/主机/系统/软件信息
- 发现可利用的安全漏洞

典型的扫描方式

scan，主动探测

sniff，被动监听/嗅探

capture，数据包捕获(抓包)

常见的安全分析工具

扫描器：snmp

协议分析：tcpdump，wireshark



NMAP网络探测工具

支持多种探测技术

- ping 扫描
- 多端口扫描
- TCP/IP指纹校验



基本用法

nmap [扫描类型] [选项] <扫描目标>

常用的扫描类型

-sS，TCP SYN扫描(半开)

-sT，TCP 连接扫描(全开)

-sU，UDP扫描

-sP，ICMP扫描

-A，目标系统全面分析



应用实例：

```shell
nmap svr7.abc.cn	#默认扫描tcp
nmap -sU svr7.abc.cn #指定-sU扫描UDP
nmap -p 21-22 192.168.4.0/24	#检测哪些主机开启FTP，ssh服务端
nmap -n -sP 192.168.4.0/24		#检测目标主机存活状态(是否ping通)
nmap -A 192.168.4.110 			#-A相当于(-O (OS检测)、-sV(版本检测)、-sC(脚本检测)、traceroute跟踪)
```



网络抓包工具

tcpdump抓包命令

tcpdump [选项] [过滤条件]

常见监控选项

-i 指定监控的网络接口

-A 转换为ACSII码，以方便阅读

-w 将数据包信息保存到指定文件

-r 从指定文件读取数据包信息

-c 定义抓包的个数(默认是无限抓包ctrl+c结束抓包)



tcpdump过滤条件

类型：host、net、port、portrange 600-800

方向：src、dst

协议：tcp、udp、ip、wlan、arp...

多个条件组合： and、or、not



应用示例：

```shell
tcpdump -A dst host 192.168.4.5 and tcp port 110 #按条件(访问指定的pop3服务)抓取数据包
tcpdump -A -w ftp.cap host 192.168.4.5 and tcp port 21 #抓包并保存
tcpdump -A -r ftp.cap | egrep '(USER|PASS)'
```



Wireshak协议分析器

类似tcpdump，但需要图形环境

centos光盘中的2个包 wireshark wireshark-gnome



### 系统审计 ###

审计：基于事先配置的规则，记录可能发生再系统上的事件。

审计不会为系统提供额外的安全保护，但它会发现并记录违反安全策略的人及其对应的行为

记录的日志内容包括：

- 日期与事件、事件结果
- 触发事件的用户
- 所有认证机制的使用都可以被记录，如ssh等
- 对关键数据文件的修改行为等



部署audit

使用审计需要安装audit软件包

主配置文件/etc/audit/auditd.conf

```shell
yum -y install audit
cat /etc/audit/auditd.conf						#log_file=/var/log/audit/audit.log 日志文件
systemctl start auditd
systemctl enable auditd
```

 

配置审计
auditctl命令选项

-s：查询状态

-l：查看规则

-D：删除所有规则



定义临时规则

auditctl -w path -p permission -k key_name

path为需要审计的文件或目录

权限可以是r,w,x,a(文件或目录的属性发生变化)

key_name为可选项，方便识别哪些规则生成特定的日志项

```shell
auditctl -w /etc/passwd -p wa -k passwd_change		
#对/etc/passwd设置规则，对文件的写属性修改操作都会被记录审计日志
auditctl -w /etc/selinux/ -p wa -k selinux_change	
#对/etc/selinux/目录 设置规则
```



定义永久规则

写入配置文件/etc/audit/rules.d/audit.rules

```shell
vim /etc/audit/rules.d/audit.rules
-w /etc/passwd -p ws -k passwd_change
-w /usr/sbin/fdisk -p x -k partition_disks
```



审计日志

查看日志前需要定义规则

```shell
auditctl -w /etc/ssh/sshd_config -p warx -k sshd_config
tailf /var/log/audit/audit.log
```



查看日志内容

type为类型

msg为(time_stamp:ID)，时间是date+%s

arch=c000003e,代表x86_64(16进制)

sucess=yes/no，事件是否成功

a0-a3是程序调用时前4个参数，16进制编码

ppid父进程ID

auid是审核用户的id，su - test ，可以追踪su前的账户

uid，gid用户与组

tty：从哪个终端执行的命令

comm="cat"	用户在命令行执行的指令

exe="/bin/cat" 实际程序的路径

key="sshd_config" 管理员定义的策略关键字key

type=CWD 用来记录当前工作目录

type=PATH (ouid，guid) 



搜索日志

系统提供的ausearch命令可以方便的搜索特定日志

默认该程序会搜索/var/log/audit/audit.log

ausearch options -if file_name 可以指定文件名

```shell
ausearch -k sshd_config -i 
#根据key搜索日志，-i为交互式操作
```



### Nginx安全 ###

删除不需要的模块

Nginx是模块化设计，需要的模块使用--with加载模块，不需要的模块使用--without禁用模块

最小化安装永远是对的！

```shell
./configure --without-http_autoindex_module --without-http_ssl_module
make && make install 
vim nginx.conf
server {
	autoindex on;
}
```

修改版本信息

隐藏版本号信息(server_tokens off)

```shell
vim /usr/local/nginx/conf/nginx.conf

http{
server_tokens off;

}
```

限制并发

ngx_http_limit_req_module为默认模块

该模块可以降低DDos攻击风险

```shell
vim /usr/local/nginx/conf/nginx.conf
http{
limit_req_zone $binary_remote_addrazone=one:10m rate=1r/s;
	server {
				listen 80;
				server_name localhost;
				limit_req zone=one burst=5;
	}
}
```

语法：limit_req_zone key zone=name:size rate=rate;

将客户端IP信息存储名称为one的共享内存，空间为10M

1M可以存储8千个IP的信息，10M8万个主机状态

每秒中仅接受1个请求，多余的放入漏斗

漏斗超过5个则报错

limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;

limit_req zone=one burst=5;



拒绝非法请求

常见HTTP请求方式

| 请求方式 | 功能描述                                                     |
| -------- | ------------------------------------------------------------ |
| GET      | 请求指定的页面信息，并返回实体主体                           |
| HEAD     | 类似于get请求，只不过返回的响应中没有具体的内容，用与获取报头 |
| POST     | 向指定资源提交数据进行处理请求(例如提交表单或上传文件)       |
| DELETE   | 请求服务器删除指定的页面                                     |
| ...      | 其他                                                         |

禁用其他方法，仅允许(GET|POST)

```shell
vim /usr/local/nginx/conf/nginx.conf
http{
	server{
		listen 80;
	   if($request_method !~ ^(GET|POST)$){
	   	 return 444;
	   }
	}
}

#curl -i -X GET "http://ip"
#curl -i -X HEAD "http://ip"
```

防止buffer溢出

防止客户端请求数据溢出

有效降低机器Dos攻击风险

```shell
vim /usr/local/nginx/conf/nginx.conf
http{
	client_body_buffer_size 1K;
	client_header_buffer_size 1k;
	client_max_body_size 16k;
	large_client_header_buffers 4 4k;
}
```



### 数据库安全 ###

初始化安全脚本

输入旧密码，配置新root密码

remove anonymous users (删除匿名账户)

disallow root login remotely(禁止root远程登录)

remove test database(删除测试数据库)

reload privilege(刷新权限)

```shell
systemctl status mariadb
mysql_secure_installation			#执行初始化安全脚本
```

密码安全

```shell
mysqladmin -uroot -p123456 password 'mysql'
#修改密码，旧密码123456，新密码mysql
mysql -uroot -pmysql  
set password for root@'localhost'=password('123456');
#使用账户登录数据库，修改密码
select user,host,password from mysql.user;
```

binlog日志里有明文密码(5.6版本后修复了)

cat .bah_history

cat .mysql_history 

管理好历史，不使用明文登录，选择合适的版本，设置防火墙策略(禁止外网接触数据库)，使用日志，行为审计



数据备份与还原

```shell
#备份
mysqldump -uroot -p123456 mydb table > table.sql
mysqldump -uroot -p123456 mydb > mydb.sql
mysqldump -uroot -p123456 --all-databases > all.sql

#还原
mysql -uroot -p123456 mydb  < table.sql
mysql -uroot -p123456 mydb  < mydb.sql
mysql -uroot -p123456 < all.sql
```



数据安全

```shell
#创建可以远程登录的账户
mysql -uroot -p123456 
grant all on gamedb.* to tom@'%' identified by '123';
#使用tcpdump抓包
tcpdump -w log -i eth0 src or dst port 3306
#客户端远程登录数据库，查看抓包数据
mysql -utom -p123 -h 192.168.4.5
select * from mysql.user;
tcpdump -A -r log
#解决方法：使用SSL或SSH加密数据传输(mysql也有ssl加密手段，或者ssh远程连接数据库主机使用数据库)
```



### Tomcat安全 ###

隐藏版本信息

```shell
#修改tomcat主配置文件,隐藏版本信息
yum -y install java-1.8.0-openjdk-devel
cd lib/ ; jar -xf catalina.jar
vim org/apache/catalina/util/ServerInfo.properties #修改内容
vim +69 /usr/local/tomcat/conf/server.xml
<Connector port="8080" protocol="HTTP/1.1"
connectionTimeout="20000" redirectPort="8443" server="jacob" />

#测试
curl -l http://ip:8080/xx 				#头部信息
curl -l http://ip:8080					#头部信息
curl http://ip:8080/xx					#报错页面

```

删除默认的测试页面

rm -rf /usr/local/tomcat/webapps/*



### 打补丁 ###

源代码不同的版本

```shell
#1
#!/bin/bash
echo "hello world"
#2
#!/bin/bash
echo "hello world"
echo "test file"
```



diff逐行比较

原则：告诉我们怎么修改第一个文件后能得到第二个文件

选项：

-u：输出统一内容的头部信息(打补丁使用)

-r：递归对比目录中的所有资源(可以对比目录)

-a：所有文件是为文本(包括二进制程序)

-N：无文件视为空文件(空文件怎么变成第二个文件)

例：a目录没有txt文件，b目录下有txt文件，diff比较两个目录时，默认会提示txt仅在目录b有(无法根据补丁修复a缺失的文件)，diff比较时使用N选项，则diff会拿b下的txt与a下的txt空文件对比，补丁信息会明确说明如何从空文件修改后变成txt文件，打补丁即可成功



例：

```shell
mkdir {source1,source2}
echo "hello world" > source1/test.sh
echo "hello the world" > source2/test.sh
echo "test" > source2/tmp.txt
cp /bin/find source1/
cp /bin/find source2/
echo "1" >> source2/find

diff -u source1/ source2/
仅对比了文本文件test.sh; 二进制文件、tmp都没有对比差异，仅提示。
diff -uN source1/ source2/
对比了test.sh，并且使用source2目录的tmp.txt与source1的空文件对比差异
diff -Nua source1/ source2/
对比了test.sh、tmp.txt、find
```



patch打补丁

给文件生成补丁

```shell
mkdir demo; cd demo
vim test.sh
#!/bin/bash
echo "hello world"
echo "test"
vim test2.sh
#!/bin/bash
echo "hello the world"
echo "test file"

diff -Nua test1.sh test2.sh > test.patch
yum -y install patch
patch -p0 < test.patch
patch -RE < test.patch 			#还原旧版本，反向修复
patch -pnum 指定删除补丁文件中多少层路径前缀
入院时路径为/u/howard/src/blurfl/blurfl.c
-p0则整个路径不变
-p1则修改路径为u/howard/src/blurfl/blurfl.c
-p4则修改路径为blurfl/blurfl.c
-R反向修复，-E修复后如果文件为空，则删除该文件

diff -Nuar source1/ source2/ > source.patch
cd source1 
path -p1 < ../source.patch
```



### iptables防火墙 ###

RHEL默认使用firewalld作为防火墙

但firewalld底层还是调用包过滤防火墙iptables



状态跟踪表

raw表：PREROUTING、OUTPUT

包标记表

mangle表：PREROUTING、POSTROUTING、INPUT、OUTPUT、FORWARD

地址转换表

nat表：PREROUTING、POSTROUTING、OUTPUT

过滤表

filter表：INPUT、FORWARD、OUTPUT



包过滤匹配流程

规则链内的匹配顺序

顺序对比，匹配即停止(LOG除外)

若无任何匹配，则按该链的默认策略处理



iptables基本用法

管理程序位置：/sbin/iptables

指令组成：iptables [-t 表名] 选项 [链名] [条件] [-j 目标操作]



注意事项/整体规律

可以不指定表，默认为filter表

可以不指定链，默认为对应表的所有链

如果没有匹配的规则，则使用防火墙默认规则

选项/链名/目标操作用大写字母，其余都小写



基本的目标操作

ACCEPT：允许通过/放行

DROP：直接丢弃，不给出任何回应

REJECT：拒绝通过，必要时会给出提示

LOG：记录日志，然后传给下一条规则("匹配即停止"规律的唯一例外)



常用的管理选项

添加规则 

-A 在链的末尾追加一条规则

-I 在链的开头(或指定序号)插入一条规则



查看规则

-L 列出所有的规则条目

-n 以数字形式显示地址、端口等信息

--line-numbers 查看规则时，显示规则的序号



删除规则

-D 删除链内的指定序号(或内容)的一条规则

-F 清空所有的规则



默认策略

-P 为指定的链设置默认规则



例：

-A 追加 、-I 插入

```shell
iptables -t filter -A INPUT -p tcp -j ACCEPT
iptables -I INPUT -p udp -j ACCEPT
iptables -I INPUT 2 -p icmp -j ACCPT
```

-L 查看

```shell
iptables -nL INPUT
iptables -L INPUT --line-numbers
```

-D 删除 、-F 清空

```shell
iptables -D INPUT 3
iptables -nL INPUT
iptables -F 
iptables -t nat -F 
iptables -t mangle -F 
iptables -t raw -F 
```

设置默认规则

所有链的初始默认规则均为ACCEPT

通过-P选项可重置默认规则

```shell
iptables -t filter INPUT DROP
iptables -nL | head -1
```



filter表控制

开启内核的IP转发，作为网关、路由的必要条件

echo 'net.ipv4.ip_forward=1' >> /etc/sysctl.conf

echo 1 > /proc/sys/net/ipv4/ip_forward



基本的匹配条件

通用匹配

可直接使用，不依赖于其他条件或扩展

包括网络协议、IP地址、网络接口等条件

隐含匹配

要求以特定的协议匹配作为前提

包括端口、TCP标记、ICMP类型等条件



| 类别     | 选项         | 用法                             |
| -------- | ------------ | -------------------------------- |
| 通用匹配 | 协议匹配     | -p 协议名                        |
|          | 地址匹配     | -s 源地址 -d 目标地址            |
|          | 接口匹配     | -i 收数据的网卡 -o 发数据的网卡  |
| 隐含匹配 | 端口匹配     | --sport 源端口、--dport 目标端口 |
|          | ICMP类型匹配 | --icmp-type ICMP类型             |

需要取反时，用叹号  ! 



过滤规则示例

封禁IP地址/网段

主机防护，针对入网访问的源地址

网络防护，针对转发访问的源地址

```shell
iptables -A INPUT -s 192.168.4.120 -j DROP
iptables -A INPUT -s 10.0.10.0/24 -j DROP 
iptables -A FORWARD -s 192.168.0.0/16 -j DROP
iptables -A FORWARD -s 172.168.0.0/16 -j DROP 
```

保护特定网络服务

限制对指定服务端口的访问

```shell
iptables -A INPUT -s 192.168.0/24 -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -s 220.181.78.0/24 -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -p tcp --dport 22 -j DROP
```

禁用ping相关策略处理

允许本机ping其他主机，禁止其他主机ping本机

a ping请求(echo-request) b

b ping响应(echo-reply)a

```shell
iptables -A INPUT -p icmp --icmp-type echo-request -j DROP 		#禁止其他主机ping,允许本机
iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT	#允许其他主机ping
iptables -A OUTPUT -p icmp --icmp-type echo-request -j ACCEPT 	#允许本机回应
iptables -A OUTPUT -p icmp --icmp ! --icmp-type echo-request -j DROP #允许本机回应
```



扩展匹配

前提条件：有对应的防火墙模块支持

基本用法：

-m 扩展模块 --扩展条件 条件值

例：-m mac --mac-source 00:0C:29:74:BE:21

常见的扩展条件

| 扩展匹配 | 选项        | 用法                                                         |
| -------- | ----------- | ------------------------------------------------------------ |
|          | MAC地址匹配 | -m mac --mac-source MAC地址                                  |
|          | 多端口匹配  | -m multiport --sports 源端口列表 -m multiprot --dports 目标端口列表 |
|          | IP范围匹配  | -m iprange --src-range IP1-IP2 -m iprange --dst-range IP1-IP2 |



扩展示例

根据MAC地址封锁主机

适用于交换网络，针对源MAC地址，不管其IP地址变成多少

```shell
iptables -A INPUT -m mac --mac-source 00:0C:29:74:BE:21 -j DROP
```

多端口：一条规则开发多个端口等

```shell
iptables -A INPUT -m multiport --dports 20:22,25,80,110,143,16501:16800 -j ACCEPT
```

根据IP范围封锁主机

ssh登录的IP范围控制

允许从192.168.4.10-192.168.4.20登录

禁止从192.168.4.0/24网段其他的主机登录

```shell
iptables -A INPUT -p tcp --dport 22 -m iprange --src-range 192.168.4.10-192.168.4.20 -j ACCEPT
iptables -A INPUT -p tcp --dport 22 -s 192.168.4.0/24 -j DROP 
```



nat表应用

SNAT源地址转换

修改数据包的源地址，仅用于nat表的POSTROUTING链

配置SNAT共享上网

选择路由之后，针对来自局域网、即将从外网接口发出去的包，将源IP地址修改为网关的公网IP地址

```shell
iptables -t nat -A POSTROUTING -s 192.168.4.0/24 -p tcp --dport 80 -j SNAT --to-source 192.168.2.5
#--to-source 外网接口的ip地址
```

地址伪装策略

共享动态公网IP地址实现上网

- 主要针对外网接口的IP地址不固定的情况
- 将SNAT改为MASQUERADE即可
- 对于ADEL宽带拨号连接，网络接口可写为ppp+

```shell
iptables -t nat -A POSTROUTING -s 192.168.4.0/24 -o eth1 -j MASQUERADE --to-source 174.16.16.1
```



## RDBMS(关系型数据库) ##

常见软件

| 软件名     | 开源 | 跨平台 | 厂商     |
| ---------- | ---- | ------ | -------- |
| Oracle     | 否   | 是     | 甲骨文   |
| MySQL      | 是   | 是     | 甲骨文   |
| SQL Server | 否   | 否     | 微软     |
| DB2        | 否   | 是     | IBM      |
| Redis      | 是   | 是     | 开源软件 |
| Memcached  | 是   | 是     | 开源软件 |
| MongoDB    | 是   | 是     | 开源软件 |

专业术语

DB(DataBase)数据库：依照某种数据模型进行组织并存放到存储器的数据集合

DBMS(DataBase Management System)数据库管理系统：用来操纵和管理数据库的服务软件

DBS(DataBase System)数据库系统：即DB+DBMS 指带有数据库并整合了数据库管理软件的计算机系统



起源与发展

最早隶属于瑞典的MySQL AB公司，2008年1月MySQL AB被Sun收购，2009年4月Sun被Oracle收购

开源分支MariaDB：为应付MySQL可能会闭源的风险而诞生，由MySQL原作者Widenius主导开发，与MySQL保持最大程度兼容



MySQL主要特点：

适用于中小规模，关系型数据库系统，支持Linux、Uinx、Windows等多种操作系统，支持Python、Java、Perl、php等编程语言

典型应用环境：LAMP平台，与Apache HTTP Server组合，LNMP平台，与Nginx组合



构建MySQL服务

```shell
#安装软件 从官网下载RPM包 http://dev.mysql.com/downloads/mysql
mysql-community-client 			#客户端应用程序
mysql-community-common			#数据库和客户端库共享文件
mysql-community-devel			#客户端应用程序的库和头文件
mysql-community-embedded		#嵌入式函数库
mysql-community-embedded-compat #嵌入式兼容函数库
mysql-community-embedded-devel	#头文件和库文件作为MySQL的嵌入式库文件
mysql-community-libs			#MySQL数据库客户端应用程序的共享库
mysql-community-libs-compat		#客户端应用程序的共享兼容库

#yum安装，自动解决软件依赖
tar -xvf mysql-5.7.17.tar
yum -y install mysql-community-*.rpm
rpm -qa | grep -i mysql

#启动服务，首次启动，会执行数据初始化
systemctl start mysqld
systemctl enable mysqld
systemctl status mysql
netstat -anutlp | grep :3306		#查看服务信息
ps -C mysqld						#查看进程
```



相关参数

| 文件           | 说明                |
| -------------- | ------------------- |
| /etc/my.cnf    | 主配置文件          |
| /var/lib/mysql | 数据库目录          |
| 默认端口号     | 3306                |
| 进程名         | mysqld              |
| 传输协议       | TCP                 |
| 进程所有者     | mysql               |
| 进程所属组     | mysql               |
| 错误日志文件   | /var/log/mysqld.log |



### 初始化配置 ###

初始密码登录

数据库管理员为root

默认仅允许root本机连接

首次登录密码在安装软件时随机生成

随机密码存储在日志文件/var/log/mysqld.log里

连接命令 mysql -h数据库地址 -u用户 -p密码

```shell
grep 'passwrod' /var/log/mysqld.log					#查看随机密码
mysql -hlocalhost -uroot -p''						#连接
```

修改root密码

使用alter user命令修改登录密码，新密码必须满足密码策略，管理员root使用新密码连接服务

```shell
mysql> alter user root@"localhost"  identified by "密码";
mysql -hlocalhost -uroot -p密码 					   #使用新密码登陆
```

修改密码策略

| 策略名称          | 验证方式                                  |
| ----------------- | ----------------------------------------- |
| 0 or LOW          | 长度                                      |
| 1 or MEDIUM(默认) | 长度；数字，小写/大写，和特殊字符         |
| 2 or STRONG       | 长度；数字，小写/大写和特殊字符；字典文件 |

```shell
mysql>show variables like "%password%";			#查看变量
mysql>set global validate_password_policy=0;	#修改密码策略
mysql>set global validate_password_length=6;	#修改密码长度
vim /etc/my.cnf									#永久配置
[mysqld]
validate_password_policy=0
validate_password_length=6
:wq
```



连接MySQL服务

连接方式：客户端连接MySQL服务的方法

1.命令行 2.web页面 3.安装图形软件 4.编写脚本(php、java、python ......)

使用mysql命令

mysql -h服务器IP -u用户名 -p密码 [数据库名]

quit或exit退出



数据存储流程

客户端把数据存储到数据库服务器上的步骤

1.连接数据库服务器 2.建库 #类似文件夹 3.建表 #类似于文件 4.插入记录 #类似于文件内容 5.断开连接



MySQL管理环境

SQL命令使用规则

SQL命令不区分字母大小写(密码、变量值除外)

每条SQL命令以；结束

默认命令不支持Tab键自动补齐

\c	终止sql命令



### 常用的SQL命令分类 ###

管理数据库使用SQL(结构化查询语言)

1.DDL 数据定义语言 如：create alter drop

2.DML 数据操作语言 如：insert update delete

3.DCL 数据控制语言 如：grant revoke

4.DTL 数据事务语言 如：commit rollback savepoint



库管理命令

```mysql
show databases;					#显示已有的库
select user();					#显示连接用户
use 库名;						   #切换库
select database();				#显示当前所在的库
create database 库名;			   #创建新库
show tables;					#显示已有的表
drop databse 库名;			   #删除库
```

库名的命名规则

仅可以使用数字、字母、下划线、不能纯数字

区分字母大小写，具有唯一性

不可以使用指令关键字、特殊字符

```mysql
create database DB1;
create database db1;
```

表管理命令

```mysql
#建表(建存储数据的文件)
create table 库名.表名(
		字段名1 类型(宽度),
		字段名2 类型(宽度),
    	...
)DEFAULT CHARSET=utf8;			#指定中文字符集，可以给字段赋值中文

create table db1.stuinfo(
		name char(15),
		homeaddr char(20));
		
#查看表结构
desc 库名.表名;					 #查看表结构
drop table 库名.表名;			 #删除表

```

记录管理命令

```mysql
#记录(类似于文件里的行)
select * from 库名.表名;			  #查看表记录
insert into 库名.表名 values(值列表);	#插入表记录
update 库名.表名 set 字段=值;			#修改表记录
delete from 表名;					   #删除表记录

insert into db1.stuinfo values("jim","usa"),("lilei","china");
select * from db1.stuinfo;
update db1.stuinfo set homeaddr="beijing";
```



### MySQL数据类型 ###

数值型：体重、身高、成绩、工资

字符型：姓名、工作单位、通信住址

枚举型：兴趣爱好、性别、专业

日期时间型：出生日期、注册时间



字符类型

定长char：字符个数

最大字符个数255

不够指定字符个数时在右边用空格补全

字符个数超出时，无法写入数据

```mysql
create table db1.t1(
name char(5),
homedir char(50)
);
insert into db1.t1 values("bob","usa");
```

变长varchar：字符个数

按数据实际大小分配存储空间

字符个数超出时，无法写入数据

大文本类型：text/blob

字符数大于65535存储时使用

```mysql
create table db1.t2(
name char(5),
email varchar(30)
);
insert into db1.t2 values("lucy","lucy@tedu.cn");
```



数值类型

整数型(只能存储整数)

| 类型      | 名称               | 有符号范围     | 无符号范围 |
| --------- | ------------------ | -------------- | ---------- |
| tinyint   | 微小整数           | -128 ~ 127     | 0 ~ 255    |
| smallint  | 小整数             | -32768 ~ 32767 | 0 ~ 65535  |
| mediumint | 中整数             | -2^23 ~ 2^23-1 | 0 ~ 2^24-1 |
| int       | 大整数             | -2^31 ~ 2^31-1 | 0 ~ 2^32-1 |
| bigint    | 极大整数型         | -2^63 ~ 2^63-1 | 0 ~ 2^64-1 |
| unsigned  | 使用无符号存储范围 |                |            |



浮点型

格式1：字段名 类型;

格式2：字段名 类型(总宽度，小数位数)

| 类型   | 名称   | 有符号范围                                             | 无符号范围                                            |
| ------ | ------ | ------------------------------------------------------ | ----------------------------------------------------- |
| float  | 单精度 | -3.402823466E + 38到 -1.175494351E - 38                | 1.175494351E - 38 到 3.402823466E + 38                |
| double | 双精度 | -1.7976931348623157E + 308到 -2.225073858507201E - 308 | 2.2250738585072014E - 308到 1.7976931348623157E + 308 |

```mysql
create table db1.t3(pay float ,id double);
create table db1.t4(pay float(5,2), id double(4,2));
insert into db1.t4 values(9999,9999);			#报错
```



日期时间类型

日期 date

- 范围：0001-01-01 ~ 9999-12-31
- 格式：yyyymmdd

年 year

- 范围：1901~2155
- 格式：yyyy

时间 time

- 格式：HH:MM:SS



关于日期时间字段

当未给timestamp字段赋值时，自动以当前系统时间赋值，而datetime值位NULL(空)

year类型

要求使用4位数赋值

当使用2位赋值时：

01~69视为2001~2069

70~99视为1970~1999



时间函数

MySQL服务内置命令

可以使用时间函数给字段赋值

| 类型      | 用途                   |
| --------- | ---------------------- |
| curtime() | 获取当前的系统时间     |
| curdate() | 获取当前的系统日期     |
| now()     | 获取当前系统日期和时间 |
| year()    | 获取年                 |
| month()   | 获取月                 |
| day()     | 获取日                 |
| date()    | 获取日期               |
| time()    | 获取时间               |



枚举类型

enum单选

格式：字段名 enum(值1，值2，值N)

仅能选择一个值

字段值必须在列表里选择

```mysql
create table db1.t5(
		name char(5),
		sex enum("boy","girl","no"));
insert into db1.t5 values("bob","man");
```

set多选

格式：字段名 set(值1，值2，值N)

选择一个或多个值

字段值必须在列表里选择

```mysql
create table db1.t6(
name char(5),
likes set("eat","game","music","money"));
inset into db1.t6 values("jerry","eat,game")
```



### 表结构 ###

约束条件

查看约束条件

```mysql
desc 库名.表名;
字段名 | 类型 | 空|键值 | 默认值 | 额外设置
```

设置约束条件

null 允许为空(默认设置)

not null 不允许为null(空)

key 键值类型

default 设置默认值，缺省为NULL

extra 额外设置



修改表结构

用法：alter table 库名.表名 执行动作;

| 执行动作 | 含义         |
| -------- | ------------ |
| add      | 添加字段     |
| modify   | 修改字段类型 |
| change   | 修改字段名   |
| drop     | 删除字段     |
| rename   | 修改表名     |



添加新字段

用法：新字段默认添加在字段末尾

alter table 库名.表名 add 字段名 类型(宽度) 约束条件 ;

```mysql
alter table db1.t2
add 
name char(15)first;
```



修改字段类型

用法：修改的字段类型不能与已存储的数据冲突

alter table 库名.表名

modify 字段名 类型(宽度)  约束条件;

```mysql
alter table db1.t2
modify 
id int;
```



修改字段名

用法：也可以用来修改字段类型

alter table 库名.表名 change 源字段名 新字段名 类型(宽度) 约束条件;

```mysql
alter table db1.t2 change id user_num int;
```



删除字段

用法：表中有多条记录时，所有列的此字段的值都会被删除

alter table 库名.表名 drop 字段名;

```mysql
alter table db1.t2 drop user_num , drop pay;
```



修改表名

用法：表对应的文件名，也被改变，表记录不受影响

alter table 表名 rename 新表名;

```mysql
alter table t2 rename school;
```



### MySQL键值 ###

键值类型

| 键值类型    |          |
| ----------- | -------- |
| index       | 普通索引 |
| unique      | 唯一索引 |
| fulltext    | 全文索引 |
| primary key | 主键     |
| foreign key | 外键     |



索引介绍

类似于书的目录

对表中字段值进行排序

索引类型包括：Btree、B+tree、hash



索引优缺点

优点：通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性，可以加快数据的查询速度

缺点：当对表中的数据进行增加、删除和修改的时候，索引也要动态的调整，降低了数据的维护速度，索引需要占物理空间



index普通索引

- 一个表中可以有多个index字段
- 字段的值允许重复，且可以赋NULL值
- 通常把做为查询条件的字段设置为index字段
- index字段标志是MUL



建表的时候创建索引

```mysql
create table tea4(
id char(6) NOT NULL,
name varchar(4) NOT NULL,
age int(3) NOT NULL,
gender ENUM("boy","girl") DEFAULT "boy",
INEX(id), INDEX(name));
```

在已有的表里创建索引

create index 索引名 on 表名(字段名);

删除索引

drop index 索引名 on 表名;

查看索引信息

show index from 表名 \G;



primary key 主键

- 字段值不允许重复，且不允许赋NULL值
- 一个表中只能有一个primary key字段
- 多个字段都作为主键，称为复合主键，必须一起创建
- 主键字段的标志是PRI
- 主键通常与auto_increment连用
- 通常把表中唯一标识记录的字段设置为主键[记录编号字段]



建表时创建主键

```mysql
create table t8(
name char(3) primary key,
id int
);
```

在已有表里添加主键

alter table 表名 add primary key(字段名)

删除主键(移除主键前，如果有自增属性，必须先去掉)

alter table 表名 drop primary key;



创建复合主键

primary key(字段名列表)

```mysql
create table t5(
name char(10),
class char(7),
status enum("yes","no"),
primary key(name,class));
```

与auto_increment连用(自增)

```mysql
create table t6(
id int primary key auto_increment,
name char(10),
sex enum("man","woman"));
```



foregin key外键

外键功能：插入记录时，字段值在另一个表字段值范围内选择

- 表存储引擎必须时innodb
- 字段类型要一致
- 被参照字段必须要是索引类型的一种(primary key)



创建外键

```mysql
create table 表名(
	字段名列表，
	foreign key(字段名) references 表名(字段名) 		#指定外键
    on update cascade 							     #同步更新
    on update cascade 								 #同步删除
    )engine=innodb;									 #指定存储引擎
```

删除外键

alter table 表名 drop foreign key 外键名；

通过show create table 表名\G查看外键名CONSTRAINT



### 数据导入导出 ###

搜索路径

```mysql
#查看搜索路径
show variables like "secure_file_priv";				#查看
#默认是/var/lib/mysql-files/
```

修改搜索路径

```shell
#创建目录并修改所有者，修改主配置文件，重启服务
mkdir /myload
chown mysql /myload
vim /etc/my.cnf
[mysqld]
secure_file_priv="/myload"
:wq
systemctl restart mysqld
```



数据导入

默认只有root用户有数据导入权限，先建表，再导入数据

命令格式：

```mysql
load data infile "目录名/文件名"
into table 库名.表名
fields terminated by "分隔符"
lines terminated by "\n";
```

注意事项：

字段分隔符要与文件一致

表字段类型和字段个数要与文件匹配

导入数据时指定文件的绝对路径



数据导出

命令格式

```mysql
#格式1
select命令 into outfile "目录名/文件名";
#格式2
select命令 into outfile "目录名/文件名" fields terminated by "分隔符";
#格式3
select命令 into outfile "目录名/文件名" fields terminated by "分隔符" lines terminated by "\n";
```

注意事项：

导出数据行数由SQL查询决定

导出的是表记录，不包括字段名

自动创建存储数据的文件

存储数据文件，具有唯一性



### 管理表记录 ###

增加表记录

格式1：添加1条记录，给所有字段赋值

```mysql
insert into 表名 values(字段值列表);
```

格式2：添加多条记录，给所有字段赋值

```mysql
insert into 表名 values (字段值列表),(字段值列表),(字段值列表);
```

格式3：添加1条记录，给指定字段赋值

```mysql
insert into 表名 (字段名列表) values(字段值列表);
```

格式4：添加多条记录，给指定字段赋值

```mysql
insert into 表名 (字段名列表) values (字段值列表),(字段值列表),(字段值列表);
```

注意事项：

字段值要与字段类型相匹配

字符类型的字段，要用" "号括起来

依次给所有字段赋值时，字段名可以省略

只给部分字段赋值时，必须明确写出对应的字段名称

没有赋值的字段使用默认值或自增长赋值



查询表记录

格式1：查看所有记录

```mysql
select 字段1,...，字段n from 库名.表名;
```

格式2：条件查询

```mysql
select 字段1,...,字段n from 库名.表名 where 条件表达式;
```

注意事项：

*表示所有字段

查看当前库表记录时库名可以省略

字段列表决定显示列个数

条件决定显示行的个数



更新表记录

格式1：批量更新

```mysql
update 库名.表名 set 字段名=值,字段名=值,字段名=值,......;
```

格式2：条件匹配更新

```mysql
update 库名.表名 set 字段名=值,字段名=值,字段名=值,...... where 条件表达式;
```

注意事项：

字段值要与字段类型相匹配

对于字段类型的字段，值要用双引号括起来

若不使用where限定条件，会更新所有记录字段值

限定条件时，只更新匹配条件的记录的字段值



删除表记录

格式1：条件匹配删除

```mysql
delete from 库名.表名 where 条件表达式;
```

格式2：删除所有记录

```mysql
delete from 库名.表名;
```

注意事项：

不加条件删除表中的所有行



### 匹配条件 ###

基本匹配条件

数值比较：字段必须时数值类型

| 类型 | 比较       | 例子     |
| ---- | ---------- | -------- |
| =    | 相等       | id = 3   |
| >    | 大于       | uid > 3  |
| >=   | 大于或等于 | uid >= 3 |
| <    | 小于       | uid < 3  |
| <=   | 小于或等于 | uid <= 3 |
| !=   | 不相等     | uid != 3 |



字符比较/匹配空/非空

字段必须是字符类型

| 类型        | 比较   | 例子              |
| ----------- | ------ | ----------------- |
| =           | 相等   | name = "root"     |
| !=          | 不相等 | name != "root"    |
| is null     | 空     | shell is null     |
| is not null | 非空   | shell is not null |



逻辑匹配

多个判断条件时使用

| 类型     | 用途   | 格式                      |
| -------- | ------ | ------------------------- |
| or       | 逻辑或 | 条件1 or 条件2 or 条件3   |
| and      | 逻辑与 | 条件1 and 条件2 and 条件3 |
| ! 或 not | 逻辑非 |                           |



范围匹配

匹配范围内的任意一个值即可

| 类型                  | 比较         |
| --------------------- | ------------ |
| in(值列表)            | 在...里...   |
| not in (值列表)       | 不在...里... |
| between 数字 and 数字 | 在...之间... |



高级匹配条件

模糊查询

用法：

```mysql
where 字段名 like '通配符'
_: 表示1个字符
%：表示0~n个字符
```

示例：列出name值"4个字符"的记录

```mysql
select name from userdb.user where name like "____";
```



正则表达式

用法：

```mysql
where 字段名 regexp '正则表达式'
正则元字符：^ $ . [] * |
```

示例：列出name值"以j开头或以y结尾"的记录

```mysql
select name from db1.t2 where name regexp '^j|y$';
```



四则运算

字段必须是数值类型

| 符号 | 用途         | 例子           |
| ---- | ------------ | -------------- |
| +    | 加法         | uid + gid      |
| -    | 减法         | uid - gid      |
| *    | 乘法         | uid * gid      |
| /    | 除法         | uid / gid      |
| %    | 取余数(求模) | uid % gid      |
| ()   | 提高优先级   | (uid + gid) /2 |



### 操作查询结果 ###

聚集函数

MySQL内置数据统计函数

avg(字段名)									统计字段平均值

sum(字段名)								  统计字段之和

min(字段名)						           统计字段最小值

max(字段名)								  统计字段最大值

count(字段名)							   统计字段值个数

```mysql
select count(*) from userdb.user;
select count(name) from userdb.user where shell != "/bin/bash";
```



查询结果排序

用法：SQL查询 order by 字段名 [asc | desc];				

asc升序排序 desc降序排序

字段通常是数值类型

```mysql
select name,uid from userdb.user order by uid desc;
```



查询结构分组

用法：SQL查询 group by 字段名;

字段通常是字符类型

```mysql
select shell from userdb.user group by shell;
select shell from userdb.user where uid<=1000 group by shell;
```

distinct 字段名 		去重显示



查询结构过滤

having用法：SQL查询 having 条件表达式

```mysql
select name from userdb.user having name="bob";
select name from userdb.user where uid>=1000 having name="bob";
```



限制查询结果显示行数

用法：

SQL查询 limit 数字;							显示查询结果前多少条记录

SQL查询 limit 数字1,数字2;			   显示指定范围内的查询记录

数字1 起始行 (0表示第1行)

数字2 总行数

```mysql
select name,uid,gid from user limit 3;
select name,uid,gid from user limit 3,3;
```



### MySQL管理工具 ###

常见的管理工具

| 类型            | 界面   | 操作系统 | 说明                   |
| --------------- | ------ | -------- | ---------------------- |
| mysql           | 命令行 | 跨平台   | MySQL官方bundle包自带  |
| MySQL-Workbench | 图形   | 跨平台   | MySQL官方提供          |
| MySQL-Front     | 图形   | Windows  | 开源，轻量级客户端软件 |
| Navicat         | 图形   | Windows  | 专业、功能强大，商业版 |
| phpMyAdmin      | 浏览器 | 跨平台   | 开源，需LAMP平台       |



搭建phpMyAdmin平台

思路：

- 部署环境LAMP
- 启动httpd服务程序
- 解压phpMyAdmin包，并移动到网站目录
- 配置config.inc.php，指定MySQL服务器地址
- 浏览器访问、使用数据管理员root登录

```shell
yum -y install httpd php php-mysql
systemctl start httpd
systemctl enabled httpd 
tar -zxvf phpMyAdmin-2.11.11-all-languages.tar.gz
mv phpMyAdmin-2.11.11-all-languages /var/www/html/phpmyadmin
cd /var/www/html/phpmyadmin/
cp config.sample.inc.php config.inc.php 		#常见主配置文件
vim config.inc.php
17 $cfg['blowfish_secret'] = 'abc123';			#cookies参数
31 $cfg['Server'][$i]['host'] = 'localhost';	#数据库服务器IP地址
```



### 用户授权 ###

grant授权：添加用户并设置权限

格式

```mysql
grant 权限列表 on 库名 to 用户名@"客户端地址" identified by "密码" with grant option;
#grant option有授权权限，可选项
grant all on db4.* to yaya@"%" identified by "123qqq...A";
```



grant授权

权限列表

```shell
all							 #所有权限
usage 						 #无权限
select,update,inset 		 #个别权限
select,update(字段1,...,字段N) #指定字段
```

库名

```shell
*.* 						#所有库所有表
库名.*					   #一个库
库名.表名					  #一张表
```



用户名

授权时自定义 要有标识性

存储在mysql库的user表里

客户端地址

```shell
% 						#所有主机
192.168.4.%				#网段内的所有主机
192.168.4.1				#一台主机
localhost				#数据库服务器本机
```



示例：

添加用户mydba，对所有库、表有完去权限，允许从任何客户端连接，密码123qqq...A，且有授权权限

```mysql
grant all on *.* to mydba@"%" identified by "123qqq...A" with grant option;
```

添加用户admin允许从192.168.4.0/24网段连接，对db3库的user表有查询权限，密码123qqq...A

添加用户admin2允许从本机连接，允许对db3库的所有表，有查询/更新/插入/删除记录权限，密码123qqq...A

```mysql
grant select on db3.user to admin@"192.168.4.%" identified by "123qqq...A";
grant select,insert,update,delete on db3.* to admin2@"localhost" identified by "123qqq...A";
```



登录用户使用

| 命令                                                   | 作用                           |
| ------------------------------------------------------ | ------------------------------ |
| select user();                                         | 显示登录用户名及客户端地址     |
| show grants;                                           | 用户显示自身访问权限           |
| show grants for 用户名@"客户端地址";                   | 管理员查看已有授权用户权限     |
| set password=password("密码");                         | 授权用户连接后修改连接密码     |
| set password for 用户名@"客户端地址"=password("密码"); | 管理员重置授权用户连接密码     |
| drop user 用户名@"客户端地址";                         | 删除授权用户(必须有管理员权限) |



授权库

mysql库 记录授权信息，主要表如下：

user表 							记录已有授权用户及权限

db表								记录已有授权用户对数据库的访问权限

tables_priv表				 记录已有授权用户对表的访问权限

columns_priv表			记录已有授权用户对字段的访问权限

查看表记录可以获取用户权限；也可以通过更新表记录，修改用户权限



撤销权限

格式

```mysql
revoke 权限列表 on 库名.表 from 用户名@"客户端地址";
```



### 恢复root密码 ###

步骤：

- 停止MySQL服务程序
- 跳过授权表启动MySQL服务程序
- 修改root密码
- 以正常方式重启MySQL服务程序



操作过程

```shell
vim /etc/my.cnf
[mysqld]
......
skip-grant-tables
:wq
systemctl restart mysqld
mysql
update mysql.user set authentication_string=password("密码") where user="root" and host="localhost";
flush privileges;
quit;
```



重置root密码

在shell命令行修改登陆密码，需要验证旧密码

```shell
mysqladmin -uroot -p password "新密码"
```



### 完全备份 ###

数据备份方式：

物理备份(冷备：cp、tar、...)

逻辑备份：mysqldump 备份命令 mysql 恢复命令



物理备份及恢复

备份操作

cp -r /var/lib/mysql			备份目录/mysql.bak

tar -zcvf /root/mysql.tar.gz	/var/lib/mysql/*

恢复操作

cp -r 备份目录/mysql.bak /var/lib/mysql/

tar -zxvf /root/mysql.tar.gz -C /var/lib/mysql/

chown -R mysql:mysql /var/lib/mysql



逻辑备份

数据备份策略

完全备份：备份所有数据

增量备份：备份上次备份后，所有新产生的数据

差异备份：备份完全备份后，所有新产生的数据



完全备份及恢复

```shell
mysqldump -uroot -p密码 库名 > 目录/xxx.sql
mysql -uroot -p密码 [库名] < 目录/xxx.sql
```

备份时库名表示方式

```shell
--all-databases 或 -A 			#所有库
数据库名						  #单个库
数据库名 表名						 #单张表
-B 数据库1 数据库2 				 #多个库
```

无论备份还是恢复，都要验证用户权限



示例：

将所有的库备份为allbal.sql文件

将db3库备份为db3.sql文件

```shell
mysqldump -uroot -p密码 -A > allbal.sql
mysqldump -uroot -p密码 db3 > db3.sql
```

从备份文件db3.sql重建db3库

```shell
mysql 
create database db3;
exit
mysql -uroot -p密码 db3 < db3.sql
```



### 增量备份 ###

binlog日志

也叫二进制日志，MySQL服务日志文件的一种，记录除查询之外的所有SQL命令，可用于数据备份和恢复，配置mysql主从同步的必要条件



启用日志

| 配置项                  | 用途                     |
| ----------------------- | ------------------------ |
| server_id=数字          | 指定id值(1-255)          |
| log_bin[=目录名/文件名] | 启用binlog日志           |
| max_binlog_size=数值m   | 指定日志文件容量，默认1G |

```shell
vim /etc/my.cnf
log_bin 								#启用binlog日志
server_id=100							#指定id值
systemctl restart mysqld
```



binlog相关文件

主机名-bin.index				索引文件

主机名-bin.000001			第1个二进制文件

主机名-bin.000002			第2个二进制文件

手动生成新的日志文件：

systemctl restart mysqld

mysql > flush logs; mysql -uroot -p密码 -e 'flush logs '

mysqldump --flush-logs



清理日志

删除指定编号之前的binlog日志文件

```mysql
purge master logs to "binlog文件名";
```

删除所有binlog日志，重建新日志

```mysql
reset master;
```



恢复数据

分析日志

```mysql
show variables like "binlog_format";
#三种记录方式 1.statement 报表模式(笼统的记录) 2.row 行模式(默认，将SQL分解) 3.mixed 混合模式(综合其他两种)
```

修改日志记录格式

查看日志当前记录格式:show variables like "binlog_format";

```shell
vim /etc/my.cnf
[mysqld]
binlog_format="名称"
systemctl restart mysqld
```

查看日志内容
mysqlbinlog [选项]	binlog日志文件名

| 选项                                   | 用途       |
| -------------------------------------- | ---------- |
| --start-datetime="yyyy-mm-dd hh:mm:ss" | 起始时间   |
| --stop-datetime="yyyy-mm-dd hh:mm:ss"  | 结束时间   |
| --start-position=数字                  | 起始偏移量 |
| --stop-position=数字                   | 结束偏移量 |



恢复数据

- 使用mysqlbinlog提取历史SQL操作
- 通过管道交给mysql命令执行

格式：

mysqlbinlog 日志文件 | mysql -uroot -p密码

示例：

使用编号为1的日志文件恢复数据

```shell
cd /var/lib/mysql/
mysqlbinlog mysql-bin.000001 | mysql -uroot -p123456 
```



### percona软件 ###

物理备份缺点：

跨平台性差，备份时间长，冗余备份，浪费存储空间

mysqldump备份缺点：

效率较低，备份和还原速度慢、锁表，备份过程中，数据插入和更新操作被阻塞



XtraBackup工具

在线热备份工具

备份过程种不锁库表，适合生产环境(备份那行锁那行，不影响其他行)

由专业组织Percona提供(改进MySQL分支)

主要含有两个组件：

xtrabackup：C程序，支持InnoDB/XtraDB

innobackupex：以Perl脚本封装xtrabackup，还支持MyISAM



安装percona

```shell
#yum安装自动解决依赖
yum -y install percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm
```

查看安装信息

```shell
#查看安装列表
rpm -ql percona-xtrabackup-24
/usr/bin/innobackupex		#备份innodb、xtrdb、myisam引擎的表
/usr/bin/xbcloud
/usr/bin/xbcloud_osenv
/usr/bin/xbcrypt
/usr/bin/xbstream
/usr/bin/xtrabackup			#备份innodb、xtrdb引擎的表
```

查看命令帮助

innobackupex --help			常用选项

man innobackupex  			详细帮助



innobackupex命令

常用选项

| 常用选项                     | 含义                                         |
| ---------------------------- | -------------------------------------------- |
| --host                       | 主机名                                       |
| --user                       | 用户名                                       |
| --port                       | 端口名                                       |
| --password                   | 密码                                         |
| --databases                  | 数据库名                                     |
| --no-timestamp               | 不用日期命名备份文件存储的子目录名           |
| --redo-only                  | 日志合并                                     |
| --apply-log                  | 准备恢复数据                                 |
| --copy-back                  | 拷贝数据                                     |
| --incremental 目录名         | 增量备份                                     |
| --incremental-basedir=目录名 | 增量备份时，指定上一次备份数据存储的目录名   |
| --incremental-dir=目录名     | 准备恢复数据时，指定增量备份数据存储的目录名 |
| --export                     | 导出表信息                                   |
| import                       | 导入表空间                                   |

--databases="库名"			一个库

--databases="库1 库2"	  多个库

--databases="库1.表"	    一张表



命令格式：

```shell
#安全备份
innobackupex --user 用户名 --password 密码 备份目录名 --no-timestamp
#完全恢复
innobackupex --apply-log 目录名	#准备恢复数据
innobackupex --copy-back 目录名	#恢复数据

#增量备份
innobackupex --user 用户名 --password 密码 --incremental 增量目录 --incremental-basedir=目录名 --no-timestamp
#增量恢复
innobackupex --apply-log --redo-only 目录名 --incremental-dir=目录名 #准备恢复数据
innobackupex --copy-back 目录名		#恢复数据
```



完全备份与恢

完全备份示例：

备份所有数据到/allbak目录

```shell
innobackupex --user root --password abc123 /allbak --no-timestamp
```

完全恢复：

使用备份文件恢复数据

```shell
systemctl stop mysqld
rm -rf /var/lib/mysql/*				#恢复时要求目录为空
innobackupex --apply-log /allbak	#准备恢复数据
innobackupex --copy-back /allbak	#恢复数据
chown -R mysql:mysql /var/lib/mysql
systemctl start mysqld
```



恢复单张表

操作步骤：

- 删除表空间
- 导出表信息
- 拷贝表信息文件到数据库目录下
- 修改表信息文件的所有者及组用户为mysql
- 导入表空间
- 删除数据库目录下的表信息文件
- 查看表记录



```mysql
alter table 库名.表名 discard tablespace; 		#删除表空间
innobackupex --apply-log --export 数据完全备份目录 #导出表信息
cp 数据完全备份目录/数据库名目录/表名.{ibd,cfg,exp} 数据库目录/库名目录/	#拷贝表信息文件
chown mysql:mysql 数据库目录/库名				  #修改所有者/组
alter table 库名.表名 import tablespace;		#导入表空间
select * from 库名.表名 						#查看表记录
rm -rf 数据库目录/库名/表名;					     #删除表信息文件
```



增量备份与恢复

增量备份应用示例

增量备份时，必须先有一次备份，通常是完全备份

周一完成备份，周二~周日增量备份

```shell
innobackupex --user root --password 密码 /fullbak --no-timestamp #完全备份
innobackupex --user root --password 密码 --incremental /new1dir --incremental-basedir=/fullbak --no-timestamp 			#增量备份
innobackupex --user root --password 密码 --incremental /new2dir --incremental-basedir=/new1dir --no-timestamp 		    #增量备份
```

增量恢复

```shell
systemctl stop mysqld
rm -rf /var/lib/mysql/*
innobackupex --apply-log --redo-only /fullbak	#完全恢复
innobackupex --apply-log --redo-only /fullbak --incremental-dir=/new1dir #恢复增量
innobackupex --copy-back /fullbak				#拷贝文件
chown -R myql:mysql /var/lib/mysql/
systemctl start mysqld
```



### MySQL主从同步 ###

实现数据自动同步的服务结构

主服务器：接受客户端访问连接

从服务器：自动同步主服务器数据



主从同步原理

Master：启用binlog日志

Slave：

Slave_IO：复制master主机 binlog日志文件里的SQL命令到本机的relay-log文件里

Slave_SQL：执行本机relay-log文件的SQL语句，实现与Master数据一致



构建主从同步

思路：

配置主服务器：启用binlog日志、授权用户、查看binlog日志信息

配置从服务器：设置server_id、确保与主服务器数据一致、指定主库信息、启动slave程序、查看状态信息



配置主服务器

授权用户：

- 用户权限replication slave
- 用户名自定义
- 客户端地址允许从服务器连接
- 密码自定义

```mysql
grant replication slave on *.* to repluser@"%" identified by "123qqq...A";
```

查看日志信息

```mysql
show master status\G;
```



配置从服务器

修改主配置文件my.cnf

-server_id 不允许与主服务器server_id值相同

```shell
vim /etc/my.cnf
[mysqld]
server_id = 52
systemctl restart mysqld
```

确保与主服务器数据一致

- 主服务器上备份数，将备份文件拷贝给从服务器
- 从服务器使用备份文件恢复数据
- 在从服务器查看备份文件记录的binlog日志信息

```shell
mysqldump -uroot -p密码 --master-data 数据库名 >/allbak.sql
scp /allbak.sql root@ip:/root/			#从服务器恢复数据
mysql -uroot -p密码 数据库名 < /root/allbak.sql
vim /root/allbak.sql 					#查看binlog日志名及偏移量
```



指定主服务器信息

```mysql
change master to master_host="ip",			#主服务器ip
master_user="repluse",						#主服务器授权用户
master_password="123qqq...A",				#授权用户密码
master_log_file="mysql51-bin.000001",		#主服务器binlog日志
master_log_pos=334;							#日志偏移量
start slave;								#启动slave进程
```

master信息会自动保存到/var/lib/mysql/master.info文件

若更改主服务器信息时，应先执行stop slave;修改后再执行start slave



查看slave状态：确认IO线程、SQL线程都是yes状态



从服务器相关文件：存放在数据库目录下

| 文件名                  | 说明         |
| ----------------------- | ------------ |
| master.info             | 主库信息     |
| relay-log.info          | 中继日志信息 |
| 主机名-relay-bin.xxxxxx | 中继文件     |
| 主机名-relay-bin.index  | 索引文件     |



### 主从同步模式 ###

结构类型：

基本应用 单项复制：一主 <--- 一从

扩展应用 一主多从： 从<--- 主 ---> 从 

链式复制： 主 <--- 从 <--- 从

互为主从：主 <--->主



#### 配置一主多从结构 ####

配置从服务器

修改配置文件，确保与主服务器数据一致，指定主库信息，启动slave进程

```shell
vim /etc/my.cnf
[mysqld]
server_id = id号
systemctl restart mysqld
```

```mysql
change master to master_host="ip",
master_user="用户名",
master_password="密码",
master_log_file="binlog日志文件名",
master_log_pos=偏移量;

start slave;						#启动slave进程
show slave status\G;				#检测状态
```



#### 配置主从从结构 ####

配置主服务器53

启用binlog日志，重启服务数据库服务，用户授权

```shell
vim /etc/my.cnf
[mysqld]
log_bin=日志名
server_id=id号
systemctl restart mysqld
```

```mysql
grant replication slave on *.* to 用户名@"从库ip地址" identified by "密码";
```

配置从服务器54

修改配置文件，用户授权，指定主库信息，启动slave进程

```shell
vim /etc/my.cnf
[mysqld]
server_id=id号
log-bin=日志名
log_slave_updates 		#允许级联复制
systemctl restart mysqld
```

```mysql
grant replication slave on *.* to 用户名@'%' identified by '密码';
change master to master_host="主服务器ip",
master_user="用户名",
master_password="密码",
master_log_file="binlog日志文件名",
master_log_pos=偏移量;
start slave;
show slave status\G;
```

配置从服务器55

修改配置文件，指定主库文件，启动slave进程

```shell
vim /etc/my.cnf
[mysqld]
server_id=id号
systemctl restart mysqld
```

```mysql
change master to master_host="从服务器54",
master_user="用户名",
master_password="密码",
master_log_file="binlog日志文件名",
master_log_pos=偏移量;
start slave;
show slave status\G;
```



### 复制模式 ###

异步复制：

主服务器执行完一次事务后，立即将结果返给客户端，不关心从服务器是否已经同步数据



半同步复制：

介于异步复制和全同步复制之间

主服务器在执行完一次事务后，等待至少一台从服务器同步数据完成，才将结果返回给客户端



模式配置

查看是否允许动态加载模块

默认允许

```mysql
show variables like 'have_dynamic_loading';
```



命令行加载插件：使用数据库管理员root用户连接服务配置

```mysql
install plugin rpl_semi_sync_master SONAME "semisync_master.so"		#主服务器上执行
install plugin rpl_semi_sync_sync_slave SONAME "semisync_slave.so"	#从服务器上执行
select plugin_name,plugin_status from information_schema.plugins where plugin_name like "%semi%"	#查看
```

启用半同步复制

半同步复制，默认是关闭的

```mysql
set global rpl_semi_sync_master_enabled=1;			#主服务器执行
set global rpl_semi_sync_slave_enabled=1;			#从服务器执行
show variables like "rpl_semi_sync_%_enabled";		#查看
```

永久启用半同步复制

修改主配置文件/etc/my.cnf

在[mysqld]下方添加

```shell
#主服务器
plugin-load=rpl_semi_sync_master=semisync_master.so
rpl_semi_sync_master_enabled=1

#从服务器
plugin-load=rpl_semi_sync_slave=semisync_slave.so
rpl_semi_sync_slave_enabled=1
```



是master和slave两种角色时-需同时启用

```shell
plugin-load="rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
rpl_semi_sync_master_enabled=1
rpl_semi_sync_slave_enabled=1
```



### 数据读写分离 ###

实验案例：

添加一个MySQL代理：接收客户端访问，为客户端提供访问数据接口

读写分离原理：

由MySQL代理面向客户端提供服务

收到SQL写请求时，交给master服务器处理

收到SQL读请求时，交给slave服务器处理



构建读写分离

构建思路

- 部署MySQL一主一从结构：主服务器192.168.4.51 从服务器192.168.4.52
- 部署MySQL代理服务器：装包，修改配置文件，启动服务
- 测试配置：客户端连接代理服务访问数据



部署maxscale服务

代理软件

由MySQL的兄弟公司MariaDB开发

下载地址https://downloads.maradb.com/files/MaxScale

```shell
rpm -ivh maxscale-2.1.2-1.rhel.7.x86_64.rpm
```

修改配置文件

```shell
vim /etc/maxscale.cnf
[maxscale]					#定义线程个数
threads=1
[server1]					#定义数据库服务器
type=server
address=192.168.4.51		#master主机ip地址
port=3306
protocol=MySQLBackend	

[server2]					#定义数据库服务器
type=server
address=192.168.4.52		#slave主机ip地址
port=3306
protocol=MySQLBackend

[MySQL Monitor]				#定义要监视的数据库节点
type=monitor
module=mysqlmon
servers=server1,server2		#主、从数据库的主机名
user=maxscalemon			#监控用户(检查后端服务器主从状态)
passwd=123qqq...A			#密码
monitor_interval=10000
[Read-Write Service]		#定义读写分离的数据库节点
type=service
router=readwritesplit
servers=server1,server2		#主、从数据库的主机名
user=maxscalerouter			#路由用户(检查客户端访问代理服务器时使用的用户名和密码在后端数据库种存不存在有没有对应的访问权限)
passwd=123qqq...A			#密码
max_slave_connections=100%	

[MaxAdmin Service]			#定义管理服务
type=service
router=cli
[Read-Write Listener]		#定义读写分离服务端口号
type=listener
service=Read-Write Service
port=4006
[MaxAdmin Listener]			#定义管理服务端口号
type=listener
service=MaxAdmin Service
protocol=maxscaled
socket=default
port=4016					#定义管理服务使用端口
```



在主从服务器创建授权用户

```mysql
grant replication slave,replication client on *.* to maxscalemon@'%' identified by '123qqq...A';				
#创建监控用户
grant select on mysql.* to maxscalerouter@'%' identified by '123qqq...A'; 
#创建路由用户
```



启动服务

启动服务、查看端口、停止服务

```shell
maxscale -f /etc/maxscale.cnf
netstat -anutlp | grep maxscale 
kill -9 PID号
```



测试配置

在代理服务器本机访问管理

```shell
maxadmin -uadmin -pmariadb -P端口
list servers				#查看服务器列表
```

客户端连接代理访问数据



### 多实例 ###

在一台物理主机上运行多个数据库服务



配置多实例

```shell
#安装软件
yum -y install libaio 
useradd mysql
tar -zxvf mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz
mv mysql-5.7.20-linux-glibc2.12-x86_64 /usr/local/mysql
PATH=/usr/local/mysql/bin:$PATH

vim /etc/bashrc
 export PATH=/usr/local/mysql/bin:$PATH
 
#手写配置文件
vim /etc/my.cnf						
[mysqld_multi]									#启用多实例
mysqld = /usr/local/mysql/bin/mysqld_safe		#指定进程文件路径
mysqladmin = /usr/local/mysql/bin/mysqladmin	#指定管理命令路径
user = root										#指定进程用户
[mysqldX]										#实例进程名称,x表示实例编号,如[mysqld1]
port = 3307										#端口号
datadir = /dir1									#数据库目录，要手动创建
socket = /dir1/mysql.sock						#指定sock文件的路径和名称
pid-file = /dir1/mysqld.pid						#进程pid号文件和位置
log-error = /dir1/mysqld.err					#错误日志位置
```

管理多实例

启动服务(首次启动服务会创建root登录初始密码)

停止服务

```shell
mysqld_multi start 实例编号
mysqld_multi --user=root --password=密码 stop 实例编号 
```

客户端访问

本机连接

使用初始密码连接

修改本机登陆密码

```shell
mysql -uroot -p'初始密码' -S sock文件
```



### 数据分片 ###

分库/分表

将存放在一台数据库服务器中的数据，按照特定方式进行拆分，分散存放到多台数据库服务器中，以达到分散单台服务器负载的效果



水平分割

- 横向切分：按照表中指定字段的分片规则，将表记录按行切分，分散存储到多个数据库中



垂直分割

- 纵向切分：将单个数据库的多个表按业务类型分类，分散存储到不同的数据库



MyCat

基于Java的分布式数据库系统中间件，为高并发环境的分布式存储提供解决方案

- 适合数据大量写入的存储需求
- 支持MySQL、Oracle、Sqlserver、Mongodb等
- 提供数据读写分离服务
- 提供数据分片服务
- 基于阿里巴巴Cobar进行研发的开源软件



分片规则

mycat支持提供10种分片规则

| 分片规则           | 英文                      |
| ------------------ | ------------------------- |
| 枚举法             | sharding-by-intfile       |
| 固定分片           | rule1                     |
| 范围约定           | auto-sharding-long        |
| 求模法             | mod-long                  |
| 日期列分区法       | sharding-by-date          |
| 通配取模           | sharding-by-pattern       |
| ASCII码求模通配    | sharding-by-prefixpattern |
| 编程指定           | sharding-by-substring     |
| 字符串拆分hash解析 | sharding-by-stringhash    |
| 一致性hash         | sharding-by-murmur        |



工作过程

当mycat收到一个SQL命令时

1.解析SQL命令涉及到的表

2.然后看对表的配置，如果有分片规则，则获取SQL命令里的分片字段的值，并匹配分片函数，获得分片列表

3.然后将SQL命令发往对应的数据库服务器去执行

4.最后收集和处理所有分片结果数据，并返回到客户端



部署MyCat服务

实验案例：

ip规划

| 主机名   | 角色         | 数据库 | IP地址          |
| -------- | ------------ | ------ | --------------- |
| client50 | 客户端       | 无     | 192.168.4.50/24 |
| mycat56  | 分片服务器   | 无     | 192.168.4.56/24 |
| mysql53  | 数据库服务器 | db1    | 192.168.4.53/24 |
| mysql54  | 数据库服务器 | db2    | 192.168.4.54/24 |
| mysql55  | 数据库服务器 | db3    | 192.168.4.55/24 |



安装软件

```shell
#56安装JDK,mycat软件包
yum -y install java-1.8.0-openjdk.x86_64
tar -zxvf Mycat-server-1.6.RELEASE-20161028204710-linux.tar.gz	#免安装，解压即可使用
mv mycat /usr/local/
ls /usr/local/mycat/
bin 	 catlet 	conf 	lib 		  lolgs 			wrapper.log	 mycat.log
#mycat命令 扩展功能 配置文件	mycat使用的jar包 mycat启动日志和运行日志 mycat服务启动日志 记录SQL脚本执行后的报错内容
```

重要配置文件说明

server.xml 		 设置连接账号及逻辑库

schema.xml		配置数据分片存储的表

rule.xml				分片规则

其他文件				分片规则配置文件



创建连接用户

```shell
vim /usr/local/mycat/conf/server.xml
<user name="用户名">									#连mycat服务的用户名
	<property name="password">密码</property>		 	 #用户密码
	<property name="schemas">库名</property>			 #逻辑库
</user>

<user name="admin">
	<property name="password">123456</property>		 	 #用户密码
	<property name="schemas">TESTDB</property>			 #逻辑库
	<property name="readOnly">true</property>			 #只读权限
</user>
```



配置数据分片

定义分片的表

```shell
<schema>......</schema>			#定义分片信息
<table>......</table>			#定义表
name 							#逻辑库名或逻辑表名
dataNode						#指定数据节点
rule							#指定使用的分片规则
type=global						#数据不分片存储
```

```shell
<schema name="TESTDB" ......>
	<table name="hotnews" primaryKey="ID" dataNode="dn1,dn2,dn3"
		rule="mod-long" />
	<table name="company" primaryKey="ID" type="global" dataNode="dn1,dn2,dn3" />
</schema>
```

定义数据节点

```shell
<dataNode 选项=值,....../>		#定义数据节点
name 						  #数据节点名
datahost					  #数据库服务器主机名
database					  #数据库名
```

```shell
<dataNode name="dn1" dataHost="mysql53" database="db1" />
<dataNode name="dn2" dataHost="mysql54" database="db2" />
<dataNode name="dn3" dataHost="mysql55" database="db3" />
```

定义数据库服务器IP地址及端口

```shell
<dataHost 选项=值,...>......</dataHost> #服务器主机名
name 								   #主机名(与datahost对应的主机名)
host								   #主机名(与IP地址对应的主机名)
url									   #数据库服务器IP地址及端口号
user								   #数据库服务器授权用户
password							   #授权用户密码
```

```shell
<dataHost name="mysql53" ......>
 		<heartbeat>select user()</heartbeat>
 		<writeHost host="hostM1" url="192.168.4.53:3306"
user="admin" password="密码">
		</writeHost>
</dataHost>
```

根据分片配置做相应的设置

- 添加授权用户
- 创建存储数据的库db1、db2、db3

```mysql
create database db1;			#在53服务器创建
create database db2;			#在54服务器创建
create database db3;			#在55服务器创建
grant all on *.* to admin@"%" identified by "密码";		#添加授权用户(3台数据库服务器)
```



启动服务

```shell
cd /usr/local/mycat/bin/
./mycat --help
/usr/local/mycat/bin/mycat start 
netstat -nutlp | grep :8066
```

客户端连接

```shell
mysql -h192.168.4.56 -P8066 -uroot -p123456
show databases;
use TESTDB;
show tables;
```



#### 测试配置 ####

 分片规则

sharding-by-intfile 枚举法：字段值必须在规则文件定义的值里选择

```shell
<table name="employee" primaryKey="ID" dataNode="dn1,dn2,dn3"
rule="sharding-by-intfile" />						#表使用的分片规则

<tableRule name="sharding-by-intfile">				#分片规则
		<rule> 
			<columns>sharding_id</columns>			#字段名
			<algorithm>hash-int</algorithm>			#算法
	 	</rule>
</tableRule>
<function name="hash-int"
		class="io.mycat.route.function.PartitionByFileMap">			#算法
		<property name="mapFile">partition-hash-int.txt</property>	#配置文件名
</function>		

vim /usr/local/mycat/conf/partition-hash-int.txt
10000=0			#0表示第一台数据库服务器 对应dn1
10010=1			#1表示第二台数据库服务器 对应dn2
10020=2			#2表示第三台数据库服务器 对应dn3
```



mod-long 求模法：根据字段值与设定的数字求模结果存储数据

```shell
<table name="hotnews" primaryKey="ID" autoIncrement="true"
			dataNode="dn1,dn2,dn3" rule="mod-long" />
<tableRule name="mod-long">
		<rule>
			<columns>id</columns>			#求模字段名，可定义
			<algorithm>mod-long</algorithm>	#算法
		</rule>
</tableRule>
<function name="mod-long"
		class="io.mycat.route.function.PatitionByMod">
		<!-- how many data nodee -->
		<property name="count">3</property>	#字段与值求模的数字
</function>
```



存储数据

建表

```shell
#根据分片规则和对用算法创建表结构
use TESTDB;
create table employee(
		ID int primary key,
		sharding_id int,
		name char(15),
		age int);
create table hotnews(
		id int,
		title char(30),
		comment char(200));
```

存储数据

```shell
#存储数据时必须指定字段名列表
inset into employee(ID,sharding_id,name,age)values
(1,10000,"bob",19),(2,10010,"tom",21),(3,10020,"lucy",16);
inset into employee(ID,sharding_id,name,age)values
(4,10000,"bob2",19),(5,10010,"tom2",21),(6,10020,"lucy2",16);
insert into hotnews(num,tile,comment)values(9,"sc","xxxxxx"),(10,"xx","hahahah"),(11,"xxa","sadasda");
```



添加新库/表

服务器配置

```shell
#添加新库，修改server.xml文件
<user name="root">
		<property name="password">123456</property>
		<property name="schemas">TESTDB,BBSDB</property>
</user>
```

添加新表

```shell
#修改schema.xml
<schema name="BBSDB" checkSQLschema="false" sqlMaxLimit="100">
	<table name="employee2" primaryKey="ID" dataNode="dn1,dn2,dn3"
		rule="sharding-by-intfile"/>
		
	<table name="company2" primaryKey="ID" type="global"
		dataNode="dn1,dn2,dn3" />
</schema>
```



客户端访问

连接分片服务器 建表 存储数据

```mysql
show databases;
use BBSDB;
create table company2(ID int primary key,name char(50),addr char(50));
insert into company2(ID,name,addr)
		values(1,"abc","beijing"),
		(2,"zbc","shanghai"),
		(3,"aaa","chengdu");
```



### MHA集群 ###

由日本DeNA公司youshimaton开发

一套优秀的实现MySQL高可用的解决方案

数据库的自动故障切换操作能做到在0~30秒之内完成

MHA能确保在故障切换过程中最大限度保证数据的一致性，以达到真正意义上的高可用



MHA组成

MHA Manager(管理节点)

管理所有数据库服务器

可以单独部署在一台独立的机器上

也可以部署在某台数据库服务器上

MHA Node(数据节点)

存储数据的MySQL服务器

运行在每台MySQL服务器上



MHA工作过程

由Manager定时探测集群中的master节点

当master故障时，manager自动将拥有最新数据的slave提升为新的master



#### 示例： ####

IP规划

| IP地址        | 主从同步角色 | 集群角色 | 主机名   |
| ------------- | ------------ | -------- | -------- |
| 192.168.4.50  | 客户端       | 无       | client50 |
| 192.168.4.51  | 主库         | 当前主库 | host51   |
| 192.168.4.52  | 从库         | 备用主库 | host52   |
| 192.168.4.53  | 从库         | 备用主库 | host53   |
| 192.168.4.57  | 无           | 管理主机 | mgm57    |
| 192.168.4.100 | 无           | VIP地址  | 无       |



部署MHA集群

```shell
#在所有主机上安装系统自带的perl软件包
yum -y install perl-*
#在所有主机上安装共享的perl软件包
cd mha-soft-student
yum -y install perl-*
```



配置SSH密钥对认证登陆

配置所有数据库服务器之间彼此ssh免密登录

配置管理主机ssh免密登录所有数据库服务器

```shell
#ssh-keygen								#创建秘钥对
#ssh-copy-id root@192.168.4.x			#拷贝公钥给目标主机
```



配置一主多从同步结构

配置主库51

```shell
vim /etc/my.cnf
[mysqld]
server_id=51
log-bin=master51
systemctl restart mysqld

grant replication slave on *.* to repluser@'%' identified by "123qqq...A";
show master status;
```

配置从库52

```shell
vim /etc/my.cnf
[mysqld]
server_id=52
systemctl restart mysqld

change master to master_hsot="192.168.4.51",master_user="repluser",master_password="123qqq...A",master_log_file="master51.000001",master_log_pos=441;
start slave;
```

配置从库53

```shell
vim /etc/my.cnf
[mysqld]
server_id=53
systemctl restart mysqld

change master to master_hsot="192.168.4.51",master_user="repluser",master_password="123qqq...A",master_log_file="master51.000001",master_log_pos=441;
start slave;
```



配置管理节点

```shell
#安装mha程序的软件包
rpm -ivh mha4mysql-node-0.56-0.el6.noarch.rpm
tar -zxf mha4mysql-manager-0.56
cd mha4mysql-manager-0.56
perl Makefile.pl
make && make install
```

相关管理命令

```shell
ls /root/perl5/bin/masterha_*
```

| 命令                  | 作用                 |
| --------------------- | -------------------- |
| masterha_check_ssh    | 检查MHA的SSH配置状况 |
| masterha_check_repl   | 检查MySQL复制状况    |
| masterha_manager      | 启动MHA              |
| masterha_check_status | 检测MHA运行状态      |
| masterha_stop         | 停止MHA              |

编写主配置文件

```shell
mkdir /etc/mha
vim /etc/mha/app1.cnf
[server default]						#管理服务默认配置
manager_workdir=/etc/mha				#工作目录
manager_log=/etc/mha/manager.log		#日志文件
master_ip_failover_script=/etc/mha/master_ip_failover	#故障切换脚本
ssh_user=root							#访问ssh服务用户
ssh_port=22								#ssh服务端口
repl_user=repluser						#数据同步授权用户
repl_password=123qqq...A				#密码
user=root								#监控用户
password=123qqq...A						#密码

[server1]								#指定第一台数据库服务器
hostname=192.168.4.51					#指定服务器ip地址
port=3306								#服务端口
candidate_master=1						#竞选主服务器

[server2]								#指定第二台数据库服务器
hostname=192.168.4.52					#指定服务器ip地址
port=3306								#服务端口
candidate_master=1						#竞选主服务器

[server3]								#指定第三台数据库服务器
hostname=192.168.4.53					#指定服务器ip地址
port=3306								#服务端口
candidate_master=1						#竞选主服务器
```

创建故障切换脚本

修改master_ip_failover脚本

```shell
#需手动添加代码，添加执行权限
vim +35 /etc/mha/master_ip_failover
my $vip = "192.168.4.100/24";			#定义vip地址
my $key = "1";							#定义地址编号
my $ssh_start_vip = "/sbin/ifconfig eth0:$key $vip";	#绑定vip地址
my $ssh_stop_vip = "/sbin/ifconfig eth0:$key down";		#释放vip地址

chmod +x /etc/mha/master_ip_failover
```

部署vip地址

在主库部署vip地址

```shell
ifconfig eth0:1 192.168.4.100
```



配置数据节点

安装软件包

```shell
#安装mha程序的软件包
cd mha-soft-student/
yum -y install mha4mysql-node-0.56-0.el6.noarch.rpm
```

在所有数据库服务器上做授权用户

```mysql
grant all on *.* to root@"%" identified by "123qqq...A";					#监控用户
grant replication slave on *.* to repluser@"%" identified by "123qqq...A";	#数据同步用户
```

根据角色做相应配置

```shell
vim /etc/my.cnf
[mysqld]
relay_log_purge=0
server_id=										#根据主机要修改
log-bin=										#根据主机要修改
plugin-load = "rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
#加载模块
rpl_semi_sync_master_enabled=1					#启用master模块
rpl_semi_sync_slave_enabled=1					#启用slave模块
relay_log_purge=0								#禁止自动删除中继日志文件

systemctl restart mysqld
```



测试集群环境(均在管理节点测试)

测试ssh配置

```shell
masterha_check_ssh --conf=/etc/mha/app1.cnf
ALL SSH connection tests passwd successfully #即成功
```

测试主从同步

```shell
masterha_check_repl --conf=/etc/mha/app1.cnf
Health is OK	#即成功
```

启动管理命令

```shell
masterha_manager --conf=/etc/mha/app1.cnf --remove_dead_master_conf --ignore_last_failover 		#后面两个选项为：删除宕机主机的配置，忽略xxx.health文件
```

查看状态

```shell
masterha_check_status --conf=/etc/mha/app1.cnf
```

停止服务

```shell
masterha_stop --conf=/etc/mha/app1.cnf
```



访问集群

主服务器用户授权

```shell
#在主服务器添加访问数据的连接用户
create database db9;
create table db9.a(id int);
grant select,insert on db9.* to abc@"%" identified by "123qqq...A";
#在2台从服务查看用户
show grants for abc@"%";
```

客户端访问

```shell
#在客户端连接vip地址访问数据库服务
mysql -h192.168.4.100 -uabc -p123qqq...A
show grants;
insert in to db3.a values(100);
select * from db3.a
#在2台从服务器本机可以查看到相同的数据
```



测试高可用

模拟主服务器故障：停止mysql服务，关机

```shell
systemctl stop mysqld
shutdown -h now 
```

客户端访问集群

```shell
#在从服务器查看vip地址
ifconfig eth0:1
#客户端连接vip,访问集群
mysql -h192.168.4.100 -uabc -p123qqq...A
```



修复故障服务器

配置数据库服务器

- 启动Mysql服务
- 与主服务器数据一致
- 指定主服务器信息
- 启动slave进程
- 查看状态信息

配置管理服务器

- 修改主配置文件
- 测试集群环境
- 重启管理服务
- 查看服务状态



### PXC集群 ###

基于Galera的MySQL高可用集群解决方案

Galera Cluester是Codership公司开发的一套免费开源的高可用方案

PXC集群主要由两部分组成：Percona Server with XtraDB 和 Write Set Replication patches (同步、多主复制插件)

官网http://galeracluster.com



特点

数据强一致性、无同步延迟

没有主从切换操作，无需使用虚拟IP

支持InnoDB存储引擎

多线程复制

部署使用简单

支持节点自动加入，无需手动拷贝数据



服务端口

| 端口 | 说明                              |
| ---- | --------------------------------- |
| 3306 | 数据库服务端口                    |
| 4444 | SST端口                           |
| 4567 | 集群通信端口                      |
| 4568 | IST端口                           |
| SST  | State Snapshot Transfer全量同步   |
| IST  | Incremental State Tranfer增量同步 |



#### 示例： ####

IP规划

| 主机名     | IP地址       | 角色         |
| ---------- | ------------ | ------------ |
| pxcnoade71 | 192.168.4.71 | 数据库服务器 |
| pxcnoade72 | 192.168.4.72 | 数据库服务器 |
| pxcnoade73 | 192.168.4.73 | 数据库服务器 |



部署PXC

安装软件(3台服务器都安装)

```shell
rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm 		#安装依赖
yum -y install percona-xtrabackup-24-2.4.13-1.el7.x86_64.rpm	#在线热备程序
rpm -ivh qpress-1.1-14.11.x86_64.rpm			#递归压缩程序
tar -xvf Percona-XtraDB-Cluester-5.7.25-31.35-r463-el7-x86_64-bundle.tar
yum -y install Percona-XtraDB-Cluster-*.rpm		#集群服务程序
```

配置服务

配置文件目录：/etc/percona-xtradb-cluster.conf.d/

配置文件说明：

mysqld.cnf	数据库服务运行参数配置文件

mysqld_safe.cnf	Percona Server 5.7配置文件

wsrep.cnf 	PXC集群配置文件



修改配置文件(3台都修改)

```shell
vim /etc/percona-xtradb-cluster.conf.d/mysqld.cnf
[mysqld]
server-id=1				#不允许重复
datadir=/var/lib/mysql	#数据库目录
socket=/var/lib/mysql/mysql.sock	
log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid	#pid文件
log-bin					#启用binlog日志
log_slave_updates		#启用链式复制
expire_logs_days=7		#日志文件保留天数
```

修改Percona Server 5.7配置文件

```shell
vim /etc/percona-xtradb-cluster.conf.d/mysqld_safe.cnf
[mysqld_safe]

pid-file = /var/run/mysqld/mysqld.pid	#pid文件位置及名称
socket = /var/lib/mysql/mysql.sock		#socket文件位置及名称
```

修改PXC集群配置文件

```shell
vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf
wsrep_cluster_address=gcomm://192.168.4.71,192.168.4.72,192.168.4.73	#集群成员列表
wsrep_node_address=192.168.4.71											#本机ip地址
wsrep_cluster_name=pxc-cluster									#集群名称，3台必须相同
wsrep_node_name=pxcnode71										#本机主机名
wsrep_sst_auth="sstuser:123qqq...A"								#SST数据同步授权用户
```



启动服务

在1台服务器上执行即可(192.168.4.71)

启动集群服务，添加授权用户

```shell
systemctl start mysql@boostrap.service			#启动集群服务
grep pass /var/log/mysqld.log					#查看数据库管理员初始登录密码
mysql -uroot -p''								#使用初始密码登录
grant reload,lock tables,replication client,process on *.* to sstuser@"localhost" identified by "123qqq...A";					  #添加授权用户
```

在其他2台服务器上执行：启动数据库服务，会自动同步71主机的授权用户及管理员root密码

```shell
systemctl start mysql						
```

查看服务端口

```shell
netstat -nutlp | grep :3306
netstat -nutlp | grep :4567
```



测试配置

查看集群信息(在任意一台数据库服务器执行)

执行SQL命令 show status like "%wsrep%";

相关参数

```mysql
mysql -uroot -p123456
show status like "%wsrep%";
wsrep_incoming_addresses 		#成员列表
wsrep_cluster_size 3			#集群服务器台数
wsrep_cluster_status Primary    #集群状态
wsrep_connected ON				#连接状态
wsrep_ready	ON					#服务状态
```

测试集群功能

在任意一台服务器上添加访问数据的授权用户

在客户端使用授权用户连接任意数据库服务器都可以存储数据，且可以查看到同样的数据

建表时，必须有主键字段

```mysql
grant all on 库名.* to 用户@"%" identified by "密码";
mysql -h数据库服务器地址 -u用户 -p密码						#访问集群
```

测试故障自动恢复

任何1台数据库服务器宕机都不影响用户存取数据

服务器运行后，自动同步宕机期间的数据



### MySQL存储引擎 ###

可插拔式的组件提供

MySQL服务软件自带的功能程序，处理表的处理器

不同的存储引擎有不同的功能和数据存储方式

MySQL 5.0/5.1 ---> MyISAM

MySQL 5.5/5.6 ---> InooDB



列出可用的存储引擎类型

```mysql
show engines;
```



配置存储引擎

修改表存储引擎：建表时手动指定，未指定时，使用默认存储引擎，alter table 表名 engine=存储引擎名;



修改服务存储引擎

设置数据库服务使用的存储引擎：修改/etc/my.cnf配置文件

```shell
vim /etc/my.cnf
[mysqld]
......
default-storage-engine=存储引擎

systemctl restart mysqld
```



#### 存储引擎的特点 ####

myisam存储引擎

- 支持表级锁
- 不支持事务、事务回滚、外键

表文件：

- 表名.frm	表结构
- 表名.MYI    索引
- 表名.MYD  数据	



innodb存储引擎

- 支持行级锁定
- 支持事务、事务回滚、外键

表文件：

- 表名.frm 表名.ibd
  - 事务日志文件
    - ibdata1 
    - ib_logfile0
    - ib_logfile1



#### MySQL锁机制 ####

锁粒度

- 表级锁：对整张表加锁
- 行级锁：仅对被访问的行分别加锁

锁类型

- 读锁(共享锁)：支持并发读
- 写锁(互斥锁、排它锁)：是独占锁，上锁期间其他线程不能读表或写表

查看当前锁状态：show staus like "table_lock%";



#### 事务特性(ACID) ####

Atomic：原子性

- 事务的整个操作是一个整体，不可分割
- 要么全部成功，要么全部失败

Consistency：一致性

- 事务操作的前后，表中的记录没有变化

Isolation：隔离性

- 事务操作是互相隔离不受影响

Durability：持久性

- 数据一旦提交，不可改变，永久改变表数据



相关命令

```mysql
show variables like "autocommit";		#查看提交状态
set autocommit=off;						#关闭自动提交
rollback;								#数据回滚
commit;									#提交数据
```



## NOSQL(非关系型数据库) ##

RDBMS(关系数据库管理系统)

按照预先设置的组织结构，将数据存储在物理介质上，数据之间可以做关联操作

主流软件：MySQL,MariaDB,Oracle,DB2,SQL Server,PostgreSQL



NoSQL(not anly sql)不仅仅是sql

泛指非关系型数据库，不需要预先定义数据存储结构，每条记录可以有不同的数据类型和字段个数

主流软件：Memcached,Redis,MongoDB,CouchDB,Neo4j,FlockDB



### Redis软件 ###

Remote Dictionary Server(远程字典服务器)

一款高性能的(key/values)分布式内存数据库

支持数据持久化(定期把内存里数据存储到硬盘)

支持多种数据类型string、list、hash...

支持master-slave模式数据备份

中文网站 www.redis.cn



#### 部署redis ####

安装软件

```shell
rpm -q gcc || yum -y install gcc
tar -zxvf redis-4.0.8.tar.gz
cd redis-4.0.8
make && make install
```

初始配置

```shell
#配置服务运行参数
./utils/install_server.sh			#初始化

#相关参数
端口 6379
主配置文件 /etc/redis/6379.conf
日志文件 /var/log/redis_6379.log
数据库目录 /var/lib/redis/6379
服务启动程序 /usr/local/bin/redis-server
命令行连接命令 /usr/local/bin/redis-cli
```

管理服务

```shell
/etc/init.d/redis_6379 stop 		#停止服务
/etc/init.d/redis_6379 start 		#启动服务
ps -C redis-server 					#查看进程
netstat -nutlp | grep :6379			#查看端口
```

连接服务

```shell
redis-cli 
ping								#返回PONG即ping通 							
set name bob						#存数据
get name 							#取数据
exit								#断开连接
```



常用命令	

| 命令                  | 含义                  |
| --------------------- | --------------------- |
| set key名 key值       | 存储一个key值         |
| mset key名列表        | 存储多个key值         |
| get key名             | 获取key值             |
| mget                  | 获取多个key值         |
| select 数据库编号0-15 | 切换库                |
| keys *                | 显示所有key名         |
| keys a?               | 显示指定key名         |
| exists key名          | 测试key名是否存在     |
| ttl key名             | 查看key生存时间       |
| type key名            | 查看key类型           |
| move key名 库编号     | 移动key到指定库       |
| expire key名 数字     | 设置key有效时间       |
| del key名             | 删除指定的key         |
| flushall              | 删除内存里所有key     |
| flushdb               | 删除所有在库的所有key |
| save                  | 保存所有key到硬盘     |
| shutdown              | 停止服务              |



配置文件解析 

| 名称              | 说明     |
| ----------------- | -------- |
| NETWORK           | 网络     |
| GENERAL           | 常规     |
| SNAPSHOTTING      | 快照     |
| REPLICATION       | 复制     |
| SECURITY          | 安全     |
| CLIENTS           | 客户端   |
| MEMORY MANAGEMENT | 内存管理 |

数据单位

1k = 1000bytes

1kb = 1024bytes

1m = 1000000bytes

1mb = 1024*1024bytes

1g = 1000000000bytes

1gb = 1024x1024x1024bytes



常用配置

port 6379										端口

bind 127.0.0.1								IP地址

daemonize yes							  守护进程方式运行

databases 16								  数据库个数

logfile /var/log/redis_6379.log	日志文件

maxclients 10000						  并发连接数量

dir /var/lib/redis/6379			      数据库目录



内存管理

```shell
#内存清楚策略
volatile-lru 				#最近最少使用(针对设置了TTL的key)
allkeys-lru					#删除最少使用的key(针对所有key)
allkeys-lfu					#从所有key中清除使用频率最少的key
volatile-lfu				#从所有配置了过期时间的key中清除使用频率最少的key
volatile-random				#在设置了TTL的key里随机移除
allkeys-random				#随机移除key
volatile-ttl (minor TTL)	#移除最近过期的key
noeviction					#不删除

#优化设置
maxmemory 					#最大内存
maxmemory-policy			#定义使用策略
maxmemory-samples			#选取key模板的个数(针对lru和ttl策略)


#连接密码
vim /etc/redis/6379.conf
requirepass 123456
bind 192.168.4.50
port 6350

redis-cli -h192.168.4.50 -p 6350	#连接服务
ping								
auth 123456							#输入密码
ping								#返回PONG
redis-cli -h 192.168.4.50 -p 6350 -a 123456  			#连接时加密码
redis-cli -h 192.168.4.64 -p 6364 -a 123456 shutdown 	#停止服务
```



#### 部署LNMP+Redis ####

部署LNMP

```shell
yum -y install gcc pcre-devel zlib-devel
cd lnmp
tar -zxvf nginx-1.12.2.tar.gz
cd nginx-1.12.2
./configure
cd /root/
yum -y install php-fpm
```

修改配置

```shell
vim +64 /usr/local/nginx/conf/nginx.conf
location ~\.php${
		root html;
		fastcgi_pass 127.0.0.1:9000;
		fastcgi_index index.php;
		include fastcgi.conf;
}
/usr/local/nginx/sbin/nginx -t	#测试修改
```

启动服务

```shell
/usr/local/nginx/sbin/ngin
systemctl start php-fpm
```

编写测试文件，测试访问

```shell
vim /usr/local/nginx/html/test.php
<?php
	echo "hello world";
?>
curl http://localhost/test.php
```

配置支持Redis

```shell
#安装软件并执行初始配置
tar -zxf redis-4.0.8.tar.gz
cd redis-4.0.8
make && make install
./utils/install_server.sh

#查看服务状态
/etc/init.d/redis_6379 status

#安装php扩展
yum -y install php php-devel
rpm -q autoconf automake
tar -zxf php-redis-2.2.4.tar.gz
cd phpredis-2.2.4/
phpize 							#生成配置文件php-config及configure命令
./configure --with-php-config=/usr/bin/php-config
make && make install
vim /etc/php.ini
extension_dir = "目录名";		  #728行 模块目录
extension = "模块名";			  #730行 模块名
systemctl restart php-fpm
```

测试配置

```php
#编写、部署测试文件，查看访问结果
vim /usr/local/nginx/html/redis.php
<?php
$redis = new redis();
$redis->connect("ip地址","端口");
$redis->auth("密码");
$redis->set("linux","redhat");			#存数据
echo $redis->get("linux");				#取数据
?>
    
curl http://localhost/redis.php			#测试访问
redhat						
```



### redis集群管理 ###

#### 创建集群 ####

实验集群环境：6台redis服务器、1台管理主机、1台客户端

IP规划

| 主机名 | IP地址       | 端口 |
| ------ | ------------ | ---- |
| client | 192.168.4.50 | 无   |
| redisA | 192.168.4.51 | 6351 |
| redisB | 192.168.4.52 | 6352 |
| redisC | 192.168.4.53 | 6353 |
| redisD | 192.168.4.54 | 6354 |
| redisE | 192.168.4.55 | 6355 |
| redisF | 192.168.4.56 | 6356 |
| MGM    | 192.168.4.57 | 无   |



工作原理

object  通过 ---> CRC16 算法 --- slot(hash槽) 计算，以存取数据  



部署管理主机

```shell
#也可以部署在任意一台redis服务器上
#部署ruby脚本运行环境，创建管理集群脚本redis-trib.rb
yum -y install rubygems ruby
gem install redis-3.2.1.gem 
mkdir /root/bin								#创建命令检索目录
tar -zxvf redis-4.0.8.tar.gz	
cp redis-4.0.8/src/redis-trib.rb /root/bin/	#创建管理集群脚本
chmod +x /root/bin/redis-trib.rb	
redis-trib.rb help							#查看命令帮助
```

redis-trib脚本

用法：redis-trib.rb <command><options><arguments>

| 命令             | 描述               |
| ---------------- | ------------------ |
| create           | 创建集群           |
| check            | 检查集群           |
| info             | 查看集群信息       |
| reshard          | 重新分片           |
| del-node         | 删除主机           |
| add-node --slave | 添加slave主机      |
| add-node         | 添加master主机     |
| rebalance        | 平均分配hash slots |



配置6台redis服务器

```shell
#启用集群功能
#查看服务信息
vim /etc/redis/6379.conf
cluster-enabled yes							#启用集群功能
cluster-config-file nodes-6379.conf			#存储集群信息文件
cluster-node-timeout 5000					#超时时间(单位毫秒)
/etc/init.d/redis_6379 restart 				#重启服务
netstat -nutlp | grep redis-server			#集群通信端口 默认服务端口+10000
```

创建集群(管理主机操作)

```shell
redis-trib.rb create --replicas 1 192.168.4.51:6351 192.168.4.52:6352 192.168.4.53:6353 192.168.4.54:6354 192.168.4.55:6355 192.168.4.56:6356
#replicas 定义从服务器个数
#Using 3 masters 选举出3个主服务器 
#ALL 16384 slots covered 集群创建完成提示
```

查看集群信息

```shell
#在管理主机查看
redis-trib.rb info ip地址:端口			#查看集群信息(指定集群中任意一台主机即可)
redis-trib.rb check ip地址:端口			#检查集群详细信息(指定集群中任意一台主机即可)

#在每一台，redis服务器查看
redis-cli -h ip -p 端口
cluster info 						  #查看集群信息
cluster nodes						  #查看集群节点信息
```

访问集群

```shell
#在客户端可以连接集群中任意一台redis服务器
redis-cli -c -h ip地址 -p 端口号		   #-c 集群模式
set school abc						  #存数据
#Redirected to slot [数字] located at 192.168.4.52:6352
get school  						  #取数据
#Redirected to slot [数字] located at 192.168.4.52:6352 "abc"
```



#### 管理集群 ####

测试集群功能

故障切换测试

停止master主机的redis服务

- master宕机后对应的slave自动被选举为master
- 原master启动后会自动配置为当前master的slave

检测集群

在管理主机查看信息

```shell
redis-trib.rb check ip:端口
redis-trib.rb info	ip:端口
```

添加服务器

- 部署一台新redis服务器
  - 运行服务并启用集群配置

- 添加master主机步骤
  - 添加master主机
  - 分配hash槽(slots)

```shell
#添加时不知道角色，默认新主机被选为master
redis-trib.rb add-node 192.168.4.58:6358 192.168.4.51:6351 #后面的ip集群中任意的即可
#New node added correctly. 添加成功提示
```

重新分片

- 移除hash槽个数
- 接收hash槽个数
- 移除hash槽ID
- 同意配置

```shell
redis-trib.rb reshard 192.168.4.51:6351
4096
all
yes
```

重新平均分配hash槽

```shell
redis-trib.rb rebalance ip:端口 	#(指定集群中任意一台主机即可)		
```



添加slave服务器

- 部署一台新redis服务器
  - 运行服务并启用集群配置

- 添加slave主机

```shell
redis-trib.rb add-node --slave [--master-id id值] ip地址:端口
#如果不指主节点的id的话，会把新节点随机添加为从节点最少的主库
redis-trib.rb add-node --slave 192.168.4.59:6359 192.168.4.51:6351
#New node added correctly #添加成功提示
```



移除服务器

- 移除从服务器

从服务器没有hash槽，直接移除即可，移除时指定从服务器id值

```shell
redis-trib.rb del-node 192.168.4.51:6351 D2566ab012...
#会停止移除主机的redis服务
```

- 移除主服务器

释放占用的hash槽，移除主机

```shell
redis-trib.rb reshard 192.168.4.51:6351
#先填写占用槽个数，再写需要给哪个主机，done,yes
redis-trib.rb del-node 192.168.4.51:6351 master主机id值
```

将被移除的主机添加到集群中

- 还原集群配置(cluster reset)

- 如果有数据还要清空(flush all;save)

添加时用 add-node  或 add-node --slave --master-id 都可



### redis主从复制 ###

主从复制结构模式

一主一从、一主多从、主从从



工作原理：

slave向master发送sync命令

master启动后台存盘进程，并收集所有修改数据命令

master完成后台存盘后，传送整个数据文件到slave

slave接受数据文件，加载到内存中完成首次完全同步

后续有新数据产生时，master继续收集数据修改命令依次传给slave，完成同步



配置主从复制

示例：

一主一从：master(192.168.4.51/24) slave(192.168.4.52/24) 客户机(192.168.4.50/24)

配置从库

```shell
#redis服务器运行后，默认都是master服务器
info replication 				#查看复制信息
slaveof 192.168.4.51 6351 		#指定主服务器地址 端口号
vim /etc/redis/6379.conf		#永久配置
slaveof 192.168.4.51 6351
```

将从服务器恢复为主库(反客为主)

```shell
redis-cli -h 192.168.4.52
slaveof no one 					#临时还原为主服务器
vim /etc/redis/6379.conf		#永久配置
slaveof 192.168.4.51 6351				
```



配置带验证的主从复制

配置master

```shell
#设置连接密码，重启服务
sed -n '501p' /etc/redis/6379.conf	
requirepass 123456						#定义连接密码
```

配置slave

```shell
#设置连接密码，重启服务
vim +289 /etc/redis/6379.conf
masterauth 123456						#主库密码
```

在临时命令后config rewrite 也可以将配置写入配置文件	



哨兵服务

- 监视master服务器
- 发现master宕机后，将从服务器升级为主服务器
- 主配置文件 sentinel.conf
- 模板文件：redis-4.0.8/sentinel.conf

配置哨兵服务

```shell
#安装redis软件，创建主配置文件，启动哨兵服务
vim /etc/sentinel.conf
sentinel monitor server51 192.168.4.51 6351 1
bind 0.0.0.0							#服务地址
sentinel auth-pass server51 123456 		#连接服务密码

redis-sentinel /etc/sentinel.conf		#启动服务
```



### redis持久化 ###

RDB：Redis数据库文件

- 数据持久化方式之一
- 数据持久化默认方式
- 按照指定时间间隔，将内存中的数据集快照写入硬盘

定义RDB文件名

```shell
dbfilename "dump.rdb"					#文件名
```



使用RDB文件恢复数据

备份数据

```shell
#备份dump.rdb文件到其他位置
cp 数据库目录/dump.rdb 备份目录
```

恢复数据

```shell
#拷贝备份文件到数据库目录，启动redis服务
cp 备份目录/dump.rdb 数据库目录/
```

优化设置

```shell
#数据从内存保存到硬盘的频率
save 900 1 				#15分钟且有1个key改变即存盘
save 300 10				#5分钟且有10个key改变即存盘
save 60 10000			#1分钟且有10000个key改变即存盘

#手动存盘
save 					#阻塞写存盘
bgsave					#不阻塞写存盘
```

RDB优点和缺点

优点：高性能的持久化实现，创建一个子进程来执行持久化，先将数据写入临时文件，持久化过程结束后，再用这个临时文件替换上次持久化好的文件；过程中主进程不做任何IO操作

比较适合大规模数据恢复， 且对数据晚自修要求不是非常高的场合

缺点：意外宕机时，丢失最后一次持久化的所有数据



AOF

- 追加方式记录写操作的文件
- 记录redis服务所有写操作
- 不断的将新的写操作，追加到文件的末尾
- 默认没有启用
- 使用cat命令可以查看文件内容

启用AOF

```shell
config set appendonly yes		#启用
config rewrite 					#写进配置文件
```

使用AOF文件恢复数据

备份数据

```shell
#备份appendonly.aof文件到其他位置
cp 数据库目录/appendonly.aof 备份目录
```

恢复数据

```shell
#拷贝备份文件到数据库目录,启动redis服务
cp 备份目录/appendonly.aof  数据库目录
/etc/redis/redis_端口 start 
```

优化配置

```shell
#定义文件名
appendonly yes 					#启用aof，默认no
appendfilename "appendonly.aof"	#指定文件名

#AOF文件记录写操作的方式
appendfsync always				#时时记录，并完成磁盘同步
appendfsync everysec			#每秒记录一次，并完成磁盘同步
appendfsync no					#写入aof，不执行磁盘同步

#日志文件会不断增大，何时触发日志重写
auto-aof-rewrite-min-size 64mb	#首次重写触发值
auto-aof-rewrite-percentage 100	#再次重写，增长百分比

#修复AOF文件，把文件恢复到最后一次的正确操作
redis-check-aof --fix appendonly.aof
y
```

AOF优点和缺点

优点：可以灵活设置持久化方式，出现意外宕机时，仅可能丢失1秒的数据

缺点：持久化文件的体积通常会大于RDB方式，执行fsync策略时的速度可能会比RDB方式慢



### redis数据类型 ###

#### string字符串 ####

set key value [ex seconds] [ps milliseconds] [nx|xx]

设置key及值，过期时间可以使用秒或毫秒为单位

setrange key offset value

从偏移量开始复写key的特定位的值

```shell
set first "hello world"
setrange first 6 "redis"			#改写为hello redis
```

strlen key，统计字串长度

```shell
strlen first
```

append key value

存在则追加，不存在则创建key及value，返回key长度

```shell
append myname abc
```

setbit key offset value

对key所存储字串，设置或清除特定偏移量上的位(bit)

value值可以为1或0，offset为0~2~32之间

key不存在，则创建新key

```shell
setbit bit 0 1 		#设置bit第0位为1
setbit bit 1 0		#设置bit第1位位0
```

bitcount key

统计字串中被设置为1的比特位数量

```shell
setbit bits 0 1			#0001
setbit bits 3 1			#1001
bitconut bits			#结果为2
setbit peter 100 1		#网站上线100天用户登录了一次
setbit peter 105 1		#网站上线105天用户登录了一次
```

场景说明：记录网站用户上线频率，如用户A上线了多少天等类似的数据，如用户在某天上线，则使用setbit，以用户名为key，将网站上线日为offset，并在该offset上设置1，最后计算用户总上线次数时，使用bitcount用户名即可。即使网站运行10年，每个用户仅占用10x365比特位及456字节



decr key 

将key中的值减1，key不存在则先初始化为0，再减1

```shell
set test 10
decr test 
```

decrby key decrement 

将key中的值，减去decrement

```shell
set count 100
decrby count 20
```

get key 

返回key存储的字符串值，若key不存在则返回null

若key的值不是字串，则返回错误，get只能处理字串

getrange key start end

返回字串值中的子字串，截取范围为start和end

负数偏移量表示从末尾开始计数，-1表示最后一个字符，-2表示倒数第二个字符

```shell
set first "hello,the world"
getrange first -5 -1
getrange first 0 4
```



incr key

将key的值加1，如果key不存在，则初始为0后再加1

主要应用为计数器

```shell
set page 20
incr page
```

incrby key increment

将key的值增加increment



incrbyfloat key increment

为key中所储存的值加上浮点数增量increment

```shell
set num 16.1
incrbyfloat num 1.1
```

mget key [key...]

获取一个或多个key的值，空格分隔，具有原子性

mset key value [key value...]

设置多个key及值，空格分隔，具有原子性